# RubikCube.py by Phyllip Hall

""""
This program is a simulator and solver for the Rubik's cube puzzle.

The program will eventually architected to allow for the solving of any sized, square Rubik’s cube. The most
popular 3x3 (6-sided/colored) cube is initially implemented.

The program uses cube move conventions defined on ruwix.com (the Twisty Puzzle Wiki), and the solving algorithm
defined on rubiksplace.com. I’ve contributed to the solving algorithm where the "speedcube" algorithm assumes
human input.

I became interested in solving the Rubik's cube after seeing it being solved by a robot hand created by Open AI
(youtu.be/x4O8pojMF0w).

I’m learning Python syntax primarily through py4e.com (Python For Everyone), w3schools.com, and realpython.com.
I'm using Steve McConnell's "Code Complete: 2nd Addition" (Microsoft Press) as a software architecture style guide.


LICENSE: This is open-source software released under the terms of the
GPL (http://www.gnu.org/licenses/gpl.html).

PLATFORMS: The cube is rendered in 2D using the graphics.py library developed by
John Zelle as a companion to his book "Python Programming: An Introduction to Computer
Science" (Franklin, Beedle & Associates).

OVERVIEW: There are 4 primary classes in this program: cube(), render(), play(), and solve()
- cube() provides a 3D coordinate map of the cube and methods that simulate moves upon it:
- render() displays the faces of the cube in an application window
- play() accepts command line input to manipulate the cube
- solve() executes a multiphase algorithm that solves the cube
"""

# Version 9   11/17/19
#   * fixed bug in Phase 3 - middle layer edges
#   * added debug cgode to monitor solve progress and catch infinite loops

# Version 8   11/13/19
#   * added solve Phase 3 - middle layer edges
#   * added solve Phase 2 - top corners

# Version 7   11/12/19
#   * added first solve features - Phase 1 - top edges
#   * fixed tricky bug in turn up/turn down moves

# Version 6   11/11/19
#   * calculates size of window based configuration of cube
#   * fixed bug in left and right column moves
#   * added find cube method for each cube type - center, edge, corner

# Version 5   11/6/19
#   * significant refactor to classes that isolate the cube object, and allow independent and potentially
#     interchangeable processes for input, output, and solving algorithm
#   * abstracted cube class and variables to eventually use inheritance to support different cube types (eg. 3x3, 4x4)
#   * simplified logic for cube rotation, and completed the command library
#   * significantly increased the speed of cube rendering by changing the fill-color of squares rather
#     than moving them to simulate cube rotations
#   * loaded the program to GitHub to learn GitHub, for comment, and to share with other newbie deverlopers

# Version 4   11/2/19
#   * sped up visual processing by only moving effected squares rather than wiping and redrawing all squares
#     after each rotation command
#   * added a dictionary map to track cube positions

# Version 3   11/1/19
#   * added comments to better organize code
#   * added basic (18) 1/4 turn movements and ability to accept and execute a list of moves
#   * added cube scrambler

# Version 2   10/31/19
#   * made cubes more realistic with simulated black space between cubelets
#   * added mini cubes to show all 6 faces simultaneously
#   * changed cube data structure to use alphanumerics for "side"

# Version 1   10/30/19
#   * initializes 6-sided cube, draws single side specified by user via command line


from graphics import *
import random


##########################################################################
class Cube:

    #   primary methods
    #   rotate() - generates a list of changes to the cube's colors based on the execution of rotate commands
    #   get_render_que() - provides the list of cube face changes generated by rotate() needed to display the cube
    #   scramble() - sends a randomized set of rotation commands to the rotate method
    #   find() - returns a list of coordinates that locate requested cubes
    #   reset() - returns the cube to it's original (solved) state

    def __init__(self):
        # global cube attributes
        self.squares = {}
        self.squares_to_render = {}
        self.squares_restart = {}
        self.squares_reset = {}
        self.squares_buffer = {}

        # faces
        self.faces = {'b': ['Back', {'u': 'd', 'd': 'u', 'l': 'l', 'r': 'r'}],
                      'u': ['Up', {'u': 'b', 'd': 'f', 'l': 'l', 'r': 'r'}],
                      'd': ['Down', {'u': 'f', 'd': 'b', 'l': 'l', 'r': 'r'}],
                      'l': ['Left', {'u': 'u', 'd': 'd', 'l': 'b', 'r': 'f'}],
                      'f': ['Front', {'u': 'u', 'd': 'd', 'l': 'l', 'r': 'r'}],
                      'r': ['Right', {'u': 'u', 'd': 'd', 'l': 'f', 'r': 'b'}]}

        # 3x3 cube attributes (eventually should be instance attributes in inherited class of cube)
        self.squares_per_side = 3
        self.colors = ('skyblue1', 'white', 'yellow', 'orange', 'lawn green', 'red')

        # slice commands for 3x3 cube
        self.commands_base = (
            ['l', 'Left'], ['li', 'Left Inverted'],
            ['m', 'Middle'], ['mi', 'Middle Inverted'],
            ['r', 'Right'], ['ri', 'Right Inverted'],
            ['u', 'Up'], ['ui', 'Up Inverted'],
            ['e', 'Equatorial'], ['ei', 'Equatorial Inverted'],
            ['d', 'Down'], ['di', 'Down Inverted'],
            ['f', 'Front'], ['fi', 'Front Inverted'],
            ['s', 'Standing'], ['si', 'Standing Inverted'],
            ['b', 'Back'], ['bi', 'Back Inverted'])

        # initialize squares on cube sides
        i = -1
        for side_key in self.faces:
            i += 1
            for column in range(self.squares_per_side):
                for row in range(self.squares_per_side):
                    key = side_key + str(column) + str(row)
                    self.squares[key] = self.colors[i]

        self.squares_to_render = self.squares.copy()
        self.squares_restart = self.squares.copy()
        self.squares_reset = self.squares.copy()

    def get_faces(self):
        list_of_faces = []
        for key, data in self.faces.items():
            list_of_faces.append([key, data[0]])
        return list_of_faces

    def get_face(self, ref_face, direction):
        data = self.faces[ref_face]
        face_directions = data[1]
        return face_directions[direction]


    ######### rotation methods

    def move(self, commands):
        # executes a list of commands that manipulate the cube and it's perspective to the user

        # two types of actions - slice and turn

        # slices...
        #   9 base slice moves
        #       - l (left), m (middle), r (right), u (up), e (equatorial), d (down), f (front), s (standing), b (back)
        #       - each move turns a row or column of the puzzle in a clockwise direction from the player's perspective
        #       - if she held the puzzle facing one side and another side parallel to the ground
        #   9 inversion slice moves - li, mi, ri, ui, ei, di, fi, si, bi
        #       - target the same squares as the slices, but turn them counter clockwise

        # turns - rotate the entire cube in one of 4 directions
        #   - tu (turn up), td (turn down), tl (turn left), tr (turn right)

        # plans define how the colors will be changed to create the effect of slicing or turning squares on the cube
        # each plan is a set of pairs for which the squares identified by the second value are replaced
        # by the squares identified by the first value
        # some actions require to sets of moves - eg. a left turn requires the squares in the 0 column and left face
        # to be moved

        # row slice moves - new column positions same as old
        plan_row = ('fl', 'lb', 'br', 'rf')

        def slice_row_inverted(squares, plan, col):
            plan_inverted = invert_plan(plan)
            slice_row(squares, plan_inverted, col)

        def slice_row(squares, plan, row):
            for change in plan:
                for col in range(self.squares_per_side):
                    key_source = change[0] + str(col) + str(row)
                    key_target = change[1] + str(col) + str(row)
                    add_change(squares, key_source, key_target)

        # coordinate slice moves - all 12 color swaps are defined
        plan_left = (
            ['f00', 'd00'], ['f01', 'd01'], ['f02', 'd02'],
            ['d00', 'b22'], ['d01', 'b21'], ['d02', 'b20'],
            ['b22', 'u00'], ['b21', 'u01'], ['b20', 'u02'],
            ['u00', 'f00'], ['u01', 'f01'], ['u02', 'f02'])

        plan_middle = (
            ['f10', 'd10'], ['f11', 'd11'], ['f12', 'd12'],
            ['d10', 'b12'], ['d11', 'b11'], ['d12', 'b10'],
            ['b12', 'u10'], ['b11', 'u11'], ['b10', 'u12'],
            ['u10', 'f10'], ['u11', 'f11'], ['u12', 'f12'])

        plan_right = (
            ['f20', 'u20'], ['f21', 'u21'], ['f22', 'u22'],
            ['u20', 'b02'], ['u21', 'b01'], ['u22', 'b00'],
            ['b02', 'd20'], ['b01', 'd21'], ['b00', 'd22'],
            ['d20', 'f20'], ['d21', 'f21'], ['d22', 'f22'])

        plan_front = (
            ['u02', 'r00'], ['u12', 'r01'], ['u22', 'r02'],
            ['r00', 'd20'], ['r01', 'd10'], ['r02', 'd00'],
            ['d20', 'l22'], ['d10', 'l21'], ['d00', 'l20'],
            ['l22', 'u02'], ['l21', 'u12'], ['l20', 'u22'])

        plan_standing = (
            ['u01', 'r10'], ['u11', 'r11'], ['u21', 'r12'],
            ['r10', 'd21'], ['r11', 'd11'], ['r12', 'd01'],
            ['d21', 'l12'], ['d11', 'l11'], ['d01', 'l10'],
            ['l12', 'u01'], ['l11', 'u11'], ['l10', 'u21'])

        plan_back = (
            ['u00', 'l02'], ['u10', 'l01'], ['u20', 'l00'],
            ['l00', 'd02'], ['l01', 'd12'], ['l02', 'd22'],
            ['d02', 'r22'], ['d12', 'r21'], ['d22', 'r20'],
            ['r22', 'u20'], ['r21', 'u10'], ['r20', 'u00'])

        def slice_coordinates_inverted(squares, plan):
            plan_inverted = invert_plan(plan)
            slice_coordinates(squares, plan_inverted)

        def slice_coordinates(squares, plan):
            for change in plan:
                key_source = change[0]
                key_target = change[1]
                add_change(squares, key_source, key_target)

        # face turns
        plan_face = (
            ['00', '20'], ['10', '21'], ['20', '22'],
            ['01', '10'], ['11', '11'], ['21', '12'],
            ['02', '00'], ['12', '01'], ['22', '02'])

        def rotate_face_inverted(squares, plan, face):
            # counter-clockwise
            plan_inverted = invert_plan(plan)
            rotate_face(squares, plan_inverted, face)

        def rotate_face(squares, plan, face):
            for change in plan:
                key_source = face + change[0]
                key_target = face + change[1]
                add_change(squares, key_source, key_target)

        # cube rotation functions
        plan_rotate_left = ('fl', 'lb', 'br', 'rf')
        plan_rotate_up = ('fu', 'ub*', 'bd*', 'df')
        plan_rotate_down = ('uf', 'bu*', 'db*', 'fd')
        plan_rotate_back = (
            ['20', '02'], ['10', '12'], ['00', '22'],
            ['21', '01'], ['11', '11'], ['01', '21'],
            ['22', '00'], ['12', '10'], ['02', '20'])

        def turn_inverted(squares, plan):
            plan_inverted = invert_plan(plan)
            turn(squares, plan_inverted)

        def turn(squares, plan):
            for change in plan:
                face_source = change[0]
                face_target = change[1]
                if len(change) == 2:
                    turn_face(squares, face_source, face_target)
                else:
                    turn_face_coordinates(squares, face_source, face_target, plan_rotate_back)

        def turn_face(squares, face_source, face_target):
            for column in range(self.squares_per_side):
                for row in range(self.squares_per_side):
                    key_source = face_source + str(column) + str(row)
                    key_target = face_target + str(column) + str(row)
                    add_change(squares, key_source, key_target)

        def turn_face_coordinates(squares, face_source, face_target, plan):
            for change in plan:
                key_source = face_source + change[0]
                key_target = face_target + change[1]
                add_change(squares, key_source, key_target)

        def invert_plan(plan):
            plan_inverted = []
            for item in plan:
                plan_inverted.append(item[::-1])
            return plan_inverted

        def add_change(squares, key_source, key_target):
            color = squares.get(key_source)
            self.squares_buffer[key_target] = color
            self.squares_to_render[key_target] = color

        def accept_buffer(squares):
            for key, color in self.squares_buffer.items():
                squares[key] = color
            self.squares_buffer.clear()
            self.cube_valid()

        # rotate()
        self.squares_to_render.clear()

        for command in commands.split():
            # slices
            if command == 'l':
                slice_coordinates(self.squares, plan_left)
                rotate_face(self.squares, plan_face, 'l')
            elif command == 'li':
                slice_coordinates_inverted(self.squares, plan_left)
                rotate_face_inverted(self.squares, plan_face, 'l')
            elif command == 'm':
                slice_coordinates(self.squares, plan_middle)
            elif command == 'mi':
                slice_coordinates_inverted(self.squares, plan_middle)
            elif command == 'r':
                slice_coordinates(self.squares, plan_right)
                rotate_face(self.squares, plan_face, 'r')
            elif command == 'ri':
                slice_coordinates_inverted(self.squares, plan_right)
                rotate_face_inverted(self.squares, plan_face, 'r')

            elif command == 'u':
                slice_row(self.squares, plan_row, 0)
                rotate_face(self.squares, plan_face, 'u')
            elif command == 'ui':
                slice_row_inverted(self.squares, plan_row, 0)
                rotate_face_inverted(self.squares, plan_face, 'u')
            elif command == 'e':
                slice_row_inverted(self.squares, plan_row, 1)
            elif command == 'ei':
                slice_row(self.squares, plan_row, 1)
            elif command == 'd':
                slice_row_inverted(self.squares, plan_row, 2)
                rotate_face(self.squares, plan_face, 'd')
            elif command == 'di':
                slice_row(self.squares, plan_row, 2)
                rotate_face_inverted(self.squares, plan_face, 'd')

            elif command == 'f':
                slice_coordinates(self.squares, plan_front)
                rotate_face(self.squares, plan_face, 'f')
            elif command == 'fi':
                slice_coordinates_inverted(self.squares, plan_front)
                rotate_face_inverted(self.squares, plan_face, 'f')
            elif command == 's':
                slice_coordinates(self.squares, plan_standing)
            elif command == 'si':
                slice_coordinates_inverted(self.squares, plan_standing)
            elif command == 'b':
                slice_coordinates(self.squares, plan_back)
                rotate_face(self.squares, plan_face, 'b')
            elif command == 'bi':
                slice_coordinates_inverted(self.squares, plan_back)
                rotate_face_inverted(self.squares, plan_face, 'b')

            # turns
            elif command == 'tl':
                turn(self.squares, plan_rotate_left)
                rotate_face(self.squares, plan_face, 'u')
                rotate_face_inverted(self.squares, plan_face, 'd')
            elif command == 'tr':
                turn_inverted(self.squares, plan_rotate_left)
                rotate_face_inverted(self.squares, plan_face, 'u')
                rotate_face(self.squares, plan_face, 'd')
            elif command == 'tu':
                turn(self.squares, plan_rotate_up)
                rotate_face_inverted(self.squares, plan_face, 'l')
                rotate_face(self.squares, plan_face, 'r')
            elif command == 'td':
                turn(self.squares, plan_rotate_down)
                rotate_face(self.squares, plan_face, 'l')
                rotate_face_inverted(self.squares, plan_face, 'r')

            else:
                print('No case defined for command:', command, '\n')
            accept_buffer(self.squares)

    ######### cube methods - find
    center_cubelets = (['l11'], ['f11'], ['r11'], ['u11'], ['b11'], ['d11'])

    edge_cubelets = (
        ['f10', 'u12'], ['f01', 'l21'], ['f21', 'r01'], ['f12', 'd10'],
        ['l10', 'u01'], ['l01', 'b21'], ['l12', 'd01'], ['u10', 'b10'],
        ['u21', 'r10'], ['b01', 'r21'], ['b12', 'd12'], ['r12', 'd21'])

    corner_cubelets = (
        ['f00', 'u02', 'l20'], ['f20', 'u22', 'r00'],
        ['f02', 'l22', 'd00'], ['f22', 'r02', 'd20'],
        ['b00', 'r20', 'u20'], ['b20', 'u00', 'l00'],
        ['b02', 'r22', 'd22'], ['b22', 'l02', 'd02'])

    def find_cubes_color(self, cublet, color):
        for key in cublet:
            if self.squares[key] == color:
                return True
        return False

    def find_cube(self, cubelets, colors):
        for cublet in cubelets:
            for color in colors:
                if not self.find_cubes_color(cublet, color):
                    break
            else:
                return cublet
        print('Unable to find cublet {0} in {1}'.format(colors, cubelets))
        return None

    def find_center(self, colors):
        return self.find_cube(self.center_cubelets, colors)

    def find_edge(self, colors):
        return self.find_cube(self.edge_cubelets, colors)

    def find_corner(self, colors):
        return self.find_cube(self.corner_cubelets, colors)

    def find_cubelet(self, colors):
        if 1 == len(colors):
            return self.find_center(colors)
        elif 2 == len(colors):
            return self.find_edge(colors)
        elif 3 == len(colors):
            return self.find_corner(colors)
        else:
            print('cube.find_cubelet - no case defined for color length:', len(colors))
            return None

    def cube_valid(self):
        def cube_valid_type(cubelets):
            for cubelet in cubelets:
                colors = []
                for key in cubelet:
                    color = self.squares[key]
                    if color in colors:
                        colors.append(color)
                        print('Cube Invalid:', cubelet, colors)
                        return False
                    else:
                        colors.append(color)
                else:
                    return True
        if not cube_valid_type(self.edge_cubelets) : return False
        if not cube_valid_type(self.corner_cubelets) : return False
        return True


    ######### cube methods - other
    def get_squares_per_side(self):
        return self.squares_per_side

    def get_color(self, color_key):
        return self.squares[color_key]

    def get_render_que(self):
        return self.squares_to_render

    def get_commands_display(self):
        list = ''
        for command in self.commands_base:
            if list != '' : list += ', '
            list += command[0]
        return list

    def get_commands_execute(self):
        list = []
        for command in self.commands_base:
            list.append(command[0])
        return list

    def scramble(self, commands_cnt):
        commands = self.get_commands_execute()
        commands_list = ''

        for i in range(commands_cnt):
            idx = random.randint(0, len(commands) - 1)
            if commands_list != '': commands_list += ' '
            commands_list += commands[idx]

        self.move(commands_list)
        self.squares_reset = self.squares.copy()
        return commands_list

    def reset(self):
        self.squares = self.squares_reset.copy()
        self.squares_to_render = self.squares_reset.copy()

    def restart(self):
        self.squares = self.squares_restart.copy()
        self.squares_to_render = self.squares_restart.copy()

##########################################################################
class Render:

    def __init__(self, cube, render_on=True):
        self.win = GraphWin
        self.win_w = 0
        self.win_h = 0
        self.render_on = render_on
        self.win_inititated = False
        self.display_map = {}
        self.cube_map = {}
        self.square_size = 50

        self.win_w, self.win_h = self.init_map(cube, self.display_map, self.square_size)

    def display_on(self):
        self.render_on = True

    def display_off(self):
        self.render_on = False

    def init_map(self, cube, display_map, square_size):
        # create map of layout of cube sides
        faces = cube.get_faces()
        elements = cube.get_squares_per_side()

        margin_size = square_size
        space_btw_sides = square_size

        col_cnt = 3
        label_h = 18
        cube_row = 0

        side_w = elements * square_size + space_btw_sides
        side_h = label_h + elements * square_size + space_btw_sides

        i = -1
        for face in faces:
            side_key = face[0]
            name = face[1]

            i += 1
            # determine cube face column
            cube_col = i % col_cnt

            # determine cube face row
            if i > 0 and i % col_cnt == 0: cube_row += 1

            x_face = margin_size + (cube_col * side_w)
            y_face = margin_size + (cube_row * side_h)

            x_label = x_face + (elements * square_size / 2)
            y_label = y_face

            x_cube = x_face
            y_cube = y_label + label_h

            display_map[side_key] = [x_cube, y_cube, x_label, y_label, name]

        win_w = margin_size + (side_w * col_cnt)
        win_h = margin_size + (side_h * (cube_row + 1))

        return win_w, win_h

    def init_win(self, display_map, w, h):
        self.win = GraphWin("Rubik's Cube Solver", w, h)

        # add label of side to each face
        for element in display_map.values():
            x = element[2]
            y = element[3]
            label_txt = element[4]

            label = Text(Point(x, y), label_txt)
            label.setSize(20)
            label.setStyle('normal')
            label.draw(self.win)

    def init_squares(self, cube, display_map, cube_map, square_size):
        for key, color in cube.squares.items():
            outer_border = 1  # btw outer box
            inner_border = 2  # btw inner and outer boxes

            side = key[0]
            column = int(key[1])
            row = int(key[2])

            position = display_map[side]
            x1 = position[0]
            y1 = position[1]

            x_start = x1 + (column * square_size)
            y_start = y1 + (row * square_size)

            # outer black square
            px1 = x_start + outer_border
            py1 = y_start + outer_border

            px2 = x_start + square_size - outer_border
            py2 = y_start + square_size - outer_border

            sqr_outer = Rectangle(Point(px1, py1), Point(px2, py2))
            sqr_outer.setFill('black')
            sqr_outer.draw(self.win)

            # inner colored square
            px1 = px1 + inner_border
            py1 = py1 + inner_border

            px2 = px2 - inner_border
            py2 = py2 - inner_border
            sqr_inner = Rectangle(Point(px1, py1), Point(px2, py2))
            sqr_inner.setFill(color)
            sqr_inner.draw(self.win)

            # coordinate label
            center = Point(x_start + square_size / 2, y_start + square_size / 2)
            coordinate = str(column) + ',' + str(row)
            label = Text(center, coordinate)
            label.draw(self.win)

            element = [px1, py1, sqr_outer, sqr_inner, label]
            cube_map[key] = element

    def init_draw(self, cube):
        # init_draw
        self.init_win(self.display_map, self.win_w, self.win_h)
        self.init_squares(cube, self.display_map, self.cube_map, self.square_size)

    def draw(self, cube):
        if not self.render_on: return

        if not self.win_inititated:
            self.init_draw(cube)
            self.win_inititated = True
        else:
            squares = cube.get_render_que()
            for key, color in squares.items():
                element = self.cube_map[key]

                sqr_inner = element[3]
                sqr_inner.setFill(color)

                # label = element[4]
                # label.setText('')

    def __del__(self):
        self.win.close()

##########################################################################
def play(cube, render):
    commands_list = cube.get_commands_display()
    commands_turn = (['tl', 'left'], ['tr', 'right'], ['tu', 'up'], ['td', 'down'])
    commands_other = (['sc', 'scramble'], ['reset', 'reset'], ['so', 'solve'], ['restart', 'restart'], ['v', 'valid'], ['q', 'quit'])

    def help():
        def get_command_list(commands):
            list = ''
            for command in commands:
                if list != '': list += ', '
                list += command[0] + ' (' + command[1] + ')'
            return list

        # help
        print('\nAvailable commands...')
        print('Slices:', commands_list)
        print('Turns:', get_command_list(commands_turn))
        print('Other:', get_command_list(commands_other))
        print('\n')

    def command_line(cube):
        while True:
            inp = input('Enter commands(s) separated by spaces: ')
            if inp == 'h':
                cube.help()
            elif inp == 'sc':
                cube.scramble(1000)
                render.draw(cube)
            elif inp == 'so':
                solve.solve_cube(cube, render)
            elif inp == 'restart':
                cube.restart()
                render.draw(cube)
            elif inp == 'reset':
                cube.reset()
                render.draw(cube)
            elif inp == 'q':
                exit()
            elif inp == 'v':
                print('Cube Is Valid:', cube.cube_valid())
            else:
                cube.move(inp)
                render.draw(cube)

    # play
    help()
    command_line(cube)


##########################################################################
class Solve():
    def __init__(self):
        self.last_commands = ['', 0]

    def log_file_init(self):
        self.fout = open('/Users/phyllip/Desktop/rubikscube_trace.txt', 'w')

    def log_file_close(self):
        self.fout.close()

    def msg_user(self, message):
        self.fout.write(message + '\n')
        print(message)

    def move_cube(self, commands, message):
        self.msg_user(message)

        if self.command_in_loop(commands):
            return False
        else:
            cube.move(commands)
            render.draw(cube)
            return True

    def command_in_loop(self, commands):
        max_repeat_cnt = 10

        if commands != self.last_commands[0]:
            self.last_commands[0] = commands
            self.last_commands[1] = 1
            return False
        else:
            if self.last_commands[1] < max_repeat_cnt:
                repeats = self.last_commands[1] + 1
                self.last_commands[1] = repeats
                return False
            else:
                self.msg_user('Commands are looping')
                return True

    def get_cubelet_key(self, cube, cubelet, target_color):
        for key in cubelet:
             if target_color == cube.get_color(key):
                return key
        self.msg_user('Color: {0} not found in keys: {1}'.format(target_color, cubelet))
        return None

    def rotate_to_front_color(self, cube, new_front_color):
         if cube.get_color('f11') != new_front_color:
            if not self.move_cube('tl', 'Rotating cube to front color:' + new_front_color):
                return False
            else:
                return self.rotate_to_front_color(cube, new_front_color)

    def cubelet_solved(self, cube, cubelet):
        for square in cubelet:
            square_color = cube.get_color(square)
            face_color = cube.get_color(square[0] + '11')
            if square_color != face_color:
                return False
        else:
            return True

    def get_unsolved_squares(self, cube, squares_to_solve):
        unsolved_squares = []
        for square in squares_to_solve:
            square_color = cube.get_color(square)
            face_color = cube.get_color(square[0] + '11')
            if square_color != face_color:
                    unsolved_squares.append(square)
        return unsolved_squares

    def phase_start(self, phase, squares_to_solve):
        self.msg_user('\nPhase: "{0}" Squares to solve: {1}'.format(phase, squares_to_solve))

    def phase_end(self, cube, phase, squares_to_solve):
        unsolved_squares = self.get_unsolved_squares(cube, squares_to_solve)
        if unsolved_squares == []:
            self.msg_user('Phase {0} successfully solved'.format(phase))
            return True
        else:
            self.msg_user('Unsolved squares of phase: ' + phase + ' ' + str(unsolved_squares))
            return False

    def alg1(self, cube):
        phase = 'top layer edges'
        squares_to_solve = ('f10', 'r10', 'b10', 'l10', 'u10', 'u01', 'u21', 'u12')

        def get_cube_colors(cube):
            colors = []
            colors.append(cube.get_color('f11')) # face color is target for plan
            colors.append(cube.get_color('u11'))
            return colors

        def position_cube(cube, colors):
            plan = {
                'f01': 'f', 'f10': 'done', 'f12': 'f', 'f21': 'fi',
                'u01': 'l', 'u10': 'bi', 'u12': 'f', 'u21': 'ri',
                'l01': 'li d l', 'l10': 'l', 'l12': 'd', 'l21': 'l d li',
                'r01': 'ui r u', 'r10': 'ri', 'r12': 'di', 'r21': 'r di ri',
                'b01': 'bi di b', 'b10': 'bi', 'b12': 'di', 'b21': 'b d bi',
                'd01': 'd', 'd10': 'fi', 'd12': 'd', 'd21': 'di'}

            target_cubelet = cube.find_cubelet(colors)
            if target_cubelet is None: return False

            coordinate = self.get_cubelet_key(cube, target_cubelet, colors[0])
            if coordinate is None: return False
            command = plan[coordinate]

            if command == 'done':
                return True
            else:
                if not self.move_cube(command, 'Executing command:' + command): return False
                return position_cube(cube, colors)

        # alg1
        self.phase_start(phase, squares_to_solve)

        for face in range(4):
            self.msg_user('Solving face:' + cube.get_color('f11'))
            colors = get_cube_colors(cube)
            if not position_cube(cube, colors): return False
            self.move_cube('tl', 'Turning left...')

        return self.phase_end(cube, phase, squares_to_solve)

    def alg2(self, cube):
        phase = 'top layer corners'
        squares_to_solve = ('f00', 'f20', 'r00', 'r20', 'b00', 'b20', 'l00', 'l20', 'u00', 'u20', 'u02', 'u22')

        def get_cube(cube):
            colors = []
            colors.append(cube.get_color('u11'))
            colors.append(cube.get_color('f11'))
            colors.append(cube.get_color('r11'))
            return cube.find_cubelet(colors)

        def pre_position_cube(cube, cubelet):
            key = ''
            command = ''
            plan = {'b00r20u20': 'r di di ri d', 'b02d22r22': 'di', 'b20l00u00': 'li d d l', 'b22d02l02': 'd d',
                    'd00f02l22': 'd', 'd20f22r02': 'done', 'f00l20u02': 'l d li', 'f20r00u22': 'ri di r d'}

            # check - already solved
            if self.cubelet_solved(cube, ['f20', 'u22', 'r00']): return

            cubelet.sort()
            key = ''.join(cubelet)
            command = plan[key]
            if command == 'done': return
            self.move_cube(command, 'Positioning edge: ' + str(cubelet))

        def final_position_cube(cube):
            command = ''

            # check - already solved
            if self.cubelet_solved(cube, ['f20', 'u22', 'r00']): return

            up_face_color = cube.get_color('u11')
            if up_face_color == cube.get_color('f22'):
                command = 'f d fi'
            elif up_face_color == cube.get_color('r02'):
                command = 'ri di r'
            else:
                command = 'ri d d r d ri di r'
            self.move_cube(command, 'Solving edge: ' + str(cubelet))

        # alg2
        self.phase_start(phase, squares_to_solve)

        for face in range(4):
            self.msg_user('Solving face:' + cube.get_color('f11'))
            cubelet = get_cube(cube)
            pre_position_cube(cube, cubelet)
            final_position_cube(cube)
            self.move_cube('tl', 'Turning left...')

        return self.phase_end(cube, phase, squares_to_solve)


    def alg3(self, cube):
        phase = 'middle layer edges'
        squares_to_solve = ('f01', 'f21', 'l01', 'l21', 'b01', 'b21', 'r01', 'r21')
        insert_middle_edge_01 = 'ui li u l u f ui fi'
        insert_middle_edge_21 = 'u r ui ri ui fi u f'

        def position_top_layer_edge(cube, key):
            color = cube.get_color(key)
            if color == cube.get_color(key[0] + '11'):
                if not self.rotate_to_front_color(cube, color): return False
            else:
                if not self.move_cube('e d', 'Rotating bottom two layers of cube to form body upside down "T"...'): return False
                position_top_layer_edge(cube, key)
                return True

        def swap(cube, commands, key, type):
            self.move_cube(commands, 'Swapping "{}" edge piece:'.format(type, key))
            next_edge(cube)

        def swap_down(cube, key):
            commands = ''
            position_top_layer_edge(cube, key)

            # determine edge placement algorithm
            color_of_top_edge = cube.get_color('u12')
            if color_of_top_edge == cube.get_color('l11'):
                commands = insert_middle_edge_01
            elif color_of_top_edge == cube.get_color('r11'):
                commands = insert_middle_edge_21
            swap(cube, commands, key, 'down')

        def swap_up(cube, edge):
            # using 1st square but either would work
            commands = ''
            key = edge[0]
            face = key[0]
            coordinate = key[1:]

            # turn so that key is on face
            color = cube.get_color(face + '11')
            self.rotate_to_front_color(cube, color)

            # get swap commands
            if coordinate == '01':
                commands = insert_middle_edge_01
            else:
                commands = insert_middle_edge_21
            swap(cube, commands, key, 'up')

        def edge_is_solved(cube, edge):
            # true if edge square colors are same as their face colors
            for key in edge:
                if cube.get_color(key) != cube.get_color(key[0] + '11'):
                    return False
            else:
                return True

        def get_unsolved_edges(cube):
            edges_to_solve = (['f01', 'l21'], ['f21', 'r01'], ['r21', 'b01'], ['b21', 'l01'])
            unsolved_edges = []
            for edge in edges_to_solve:
                if not edge_is_solved(cube, edge):
                    unsolved_edges.append(edge)
            return unsolved_edges

        def edge_in_top_row(cube, target_edge):
            # true if either color of edge has coordinate '1,0'
            colors = []
            found_edge = []
            for key in target_edge:
                face_center = key[0] + '11'
                colors.append(cube.get_color(face_center))
            found_edge = cube.find_cubelet(colors)
            for key in found_edge:
                if key in ['f10', 'l10', 'b10', 'r10']:
                    return True, key
            else:
                return False, None

        def next_edge(cube):
            misoriented_edge = []
            unsolved_edges = get_unsolved_edges(cube)
            if len(unsolved_edges) == 0: return

            for edge in unsolved_edges:
                found, key = edge_in_top_row(cube, edge)
                if found:
                    return swap_down(cube, key)
                else:
                    misoriented_edge = edge
            else:
                # only misoriented edges unsolved
                swap_up(cube, misoriented_edge)

        # alg3
        self.phase_start(phase, squares_to_solve)

        # flip cube upside down
        if not self.move_cube('tu tu', 'Flipping cube upside down...'): return False

        next_edge(cube)
        return self.phase_end(cube, phase, squares_to_solve)

    def solve_cube(self, cube, render):
        def solve_phases(cube, render):
            if not self.alg1(cube): return False
            if not self.alg2(cube): return False
            if not self.alg3(cube): return False

            # render.display_on()
            # render.draw(cube)

            return True

        # solve_cube
        self.log_file_init()
        success = solve_phases(cube, render)
        self.msg_user('Cube solved successfully: ' + str(success))
        self.log_file_close()
        return success


##########################################################################
# RUN PROGRAM

cube = Cube()
render = Render(cube, False)
solve = Solve()

i = 0
for i in range(100):
    print('\nSolving #', i + 1)
    cube.scramble(100)
    render.draw(cube)
    if not solve.solve_cube(cube, render):
        cube.reset()
        print('Solve failed on attempt: {0}'.format(i + 1))
        break
else:
    print('Solved ran successfully {0} times'.format(i+1))

render.display_on()
render.draw(cube)

play(cube, render)

