# RubikCube.py by Phyllip Hall

""""
This program is a simulator and solver for the Rubik's cube puzzle.

The program will eventually architected to allow for the solving of any sized, square Rubik’s cube. The most
popular 3x3 (6-sided/colored) cube is initially implemented.

The program uses cube move conventions defined on ruwix.com (the Twisty Puzzle Wiki), and the solving algorithm
defined on speedcube.com.au. I’ve contributed to the solving algorithm where the "speedcube" algorithm assumes
human input.

I became interested in solving the Rubik's cube after seeing it being solved by a robot hand created by Open AI
(youtu.be/x4O8pojMF0w).

I’m learning Python syntax primarily through py4e.com (Python For Everyone), w3schools.com, and realpython.com.
I'm using Steve McConnell's "Code Complete: 2nd Addition" (Microsoft Press) as a software architecture style guide.


LICENSE: This is open-source software released under the terms of the
GPL (http://www.gnu.org/licenses/gpl.html).

PLATFORMS: The cube is rendered in 2D using the graphics.py library developed by
John Zelle as a companion to his book "Python Programming: An Introduction to Computer
Science" (Franklin, Beedle & Associates).

OVERVIEW: There are 4 primary classes in this program: cube(), render(), play(), and solve()
- cube() provides a 3D coordinate map of the cube and methods that simulate moves upon it:
- render() displays the faces of the cube in an application window
- play() accepts command line input to manipulate the cube
- solve() executes a multiphase algorithm that solves the cube
"""

# Version 7   11/12/19
#   * added first solve features - Phase 1 - top cross
#   * fixed tricky bug in turn up/turn down moves

# Version 6   11/11/19
#   * calculates size of window based configuration of cube
#   * fixed bug in left and right column moves
#   * added find cube method for each cube type - center, edge, corner

# Version 5   11/6/19
#   * significant refactor to classes that isolate the cube object, and allow independent and potentially
#     interchangeable processes for input, output, and solving algorithm
#   * abstracted cube class and variables to eventually use inheritance to support different cube types (eg. 3x3, 4x4)
#   * simplified logic for cube rotation, and completed the command library
#   * significantly increased the speed of cube rendering by changing the fill-color of squares rather
#     than moving them to simulate cube rotations
#   * loaded the program to GitHub to learn GitHub, for comment, and to share with other newbie deverlopers

# Version 4   11/2/19
#   * sped up visual processing by only moving effected squares rather than wiping and redrawing all squares
#     after each rotation command
#   * added a dictionary map to track cube positions

# Version 3   11/1/19
#   * added comments to better organize code
#   * added basic (18) 1/4 turn movements and ability to accept and execute a list of moves
#   * added cube scrambler

# Version 2   10/31/19
#   * made cubes more realistic with simulated black space between cubelets
#   * added mini cubes to show all 6 faces simultaneously
#   * changed cube data structure to use alphanumerics for "side"

# Version 1   10/30/19
#   * initializes 6-sided cube, draws single side specified by user via command line


from graphics import *
import random

##########################################################################
class cube:

    # primary methods
    #   rotate() - generates a list of changes to the cube's colors based on the execution of rotate commands
    #   get_render_que() - provides the list of cube face changes generated by rotate() needed to display the cube
    #   scramble() - sends a randomized set of rotation commands to the rotate method
    #   find() - returns a list of coordinates that locate requested cubes
    #   reset() - returns the cube to it's original (solved) state

    def __init__(self):
        # global cube attributes
        self.squares = {}
        self.squares_to_render = {}
        self.squares_restart = {}
        self.squares_reset = {}
        self.squares_buffer = {}

        # faces
        self.faces = {'b': ['Back', {'u':'d', 'd':'u', 'l':'l', 'r':'r'}],
                      'u': ['Up', {'u': 'b', 'd': 'f', 'l': 'l', 'r': 'r'}],
                      'd': ['Down', {'u':'f', 'd':'b', 'l':'l', 'r':'r'}],
                      'l': ['Left', {'u':'u', 'd':'d', 'l':'b', 'r':'f'}],
                      'f': ['Front', {'u':'u', 'd':'d', 'l':'l', 'r':'r'}],
                      'r': ['Right', {'u':'u', 'd':'d', 'l':'f', 'r':'b'}]}

         # 3x3 cube attributes (eventually should be instance attributes in inherited class of cube)
        self.elements = 3
        self.colors = ('skyblue1', 'white', 'yellow', 'orange', 'lawn green', 'red')

        # slice commands for 3x3 cube
        self.commands_base = (
            ['l', 'Left'], ['li', 'Left Inverted'],
            ['m', 'Middle'], ['mi', 'Middle Inverted'],
            ['r', 'Right'], ['ri', 'Right Inverted'],
            ['u', 'Up'], ['ui', 'Up Inverted'],
            ['e', 'Equatorial'], ['ei', 'Equatorial Inverted'],
            ['d', 'Down'], ['di', 'Down Inverted'],
            ['f', 'Front'], ['fi', 'Front Inverted'],
            ['s', 'Standing'], ['si', 'Standing Inverted'],
            ['b', 'Back'], ['bi', 'Back Inverted'])

        # initialize squares on cube sides
        i = -1
        for side_key in self.faces:
             i += 1
             for column in range(self.elements):
                for row in range(self.elements):
                    key = side_key + str(column) + str(row)
                    self.squares[key] = self.colors[i]

        self.squares_to_render = self.squares.copy()
        self.squares_restart = self.squares.copy()
        self.squares_reset = self.squares.copy()

    def get_faces(self):
        list = []
        for key, data in self.faces.items():
            list.append([key, data[0]])
        return list

    def get_face(self, ref_face, direction):
        data = self.faces[ref_face]
        dict = data[1]
        return dict[direction]

    ######### rotation methods
    def rotate(self, commands):
        # executes a list of commands that manipulate the cube and it's perspective to the user

        # two types of actions - slice and turn

        # slices...
        #   9 base slice moves
        #       - l (left), m (middle), r (right), u (up), e (equatorial), d (down), f (front), s (standing), b (back)
        #       - each move turns a row or column of the puzzle in a clockwise direction from the player's perspective
        #       - if she held the puzzle facing one side and another side parallel to the ground
        #   9 inversion slice moves - li, mi, ri, ui, ei, di, fi, si, bi
        #       - target the same squares as the slices, but turn them counter clockwise

        # turns - rotate the entire cube in one of 4 directions
        #   - tu (turn up), td (turn down), tl (turn left), tr (turn right)

        # plans define how the colors will be changed to create the effect of slicing or turning squares on the cube
        # each plan is a set of pairs for which the squares identified by the second value are replaced
        # by the squares identified by the first value
        # some actions require to sets of moves - eg. a left turn requires the squares in the 0 column and left face
        # to be moved

        # row slice moves - new column positions same as old
        plan_row = ('fl', 'lb', 'br', 'rf')

        def slice_row_inverted(squares, plan, col):
            plan_inverted = invert_plan(plan)
            slice_row(squares, plan_inverted, col)

        def slice_row(squares, plan, row):
            for change in plan:
                for col in range(self.elements):
                    key_source = change[0] + str(col) + str(row)
                    key_target = change[1] + str(col) + str(row)
                    add_change(squares, key_source, key_target)

        # coordinate slice moves - all 12 color swaps are defined
        plan_left = (
            ['f00', 'd00'], ['f01', 'd01'], ['f02', 'd02'],
            ['d00', 'b22'], ['d01', 'b21'], ['d02', 'b20'],
            ['b22', 'u00'], ['b21', 'u01'], ['b20', 'u02'],
            ['u00', 'f00'], ['u01', 'f01'], ['u02', 'f02'])

        plan_middle = (
            ['f10', 'd10'], ['f11', 'd11'], ['f12', 'd12'],
            ['d10', 'b12'], ['d11', 'b11'], ['d12', 'b10'],
            ['b12', 'u10'], ['b11', 'u11'], ['b10', 'u12'],
            ['u10', 'f10'], ['u11', 'f11'], ['u12', 'f12'])

        plan_right = (
            ['f20', 'u20'], ['f21', 'u21'], ['f22', 'u22'],
            ['u20', 'b02'], ['u21', 'b01'], ['u22', 'b00'],
            ['b02', 'd20'], ['b01', 'd21'], ['b00', 'd22'],
            ['d20', 'f20'], ['d21', 'f21'], ['d22', 'f22'])

        plan_front = (
            ['u02', 'r00'], ['u12', 'r01'], ['u22', 'r02'],
            ['r00', 'd20'], ['r01', 'd10'], ['r02', 'd00'],
            ['d20', 'l22'], ['d10', 'l21'], ['d00', 'l20'],
            ['l22', 'u02'], ['l21', 'u12'], ['l20', 'u22'])

        plan_standing = (
            ['u01', 'r10'], ['u11', 'r11'], ['u21', 'r12'],
            ['r10', 'd21'], ['r11', 'd11'], ['r12', 'd01'],
            ['d21', 'l12'], ['d11', 'l11'], ['d01', 'l10'],
            ['l12', 'u01'], ['l11', 'u11'], ['l10', 'u21'])

        plan_back = (
            ['u00', 'l02'], ['u10', 'l01'], ['u20', 'l00'],
            ['l00', 'd02'], ['l01', 'd12'], ['l02', 'd22'],
            ['d02', 'r22'], ['d12', 'r21'], ['d22', 'r20'],
            ['r22', 'u20'], ['r21', 'u10'], ['r20', 'u00'])

        def slice_coordinates_inverted(squares, plan):
            plan_inverted = invert_plan(plan)
            slice_coordinates(squares, plan_inverted)

        def slice_coordinates(squares, plan):
            for change in plan:
                key_source = change[0]
                key_target = change[1]
                add_change(squares, key_source, key_target)

        # face turns
        plan_face = (
            ['00', '20'], ['10', '21'], ['20', '22'],
            ['01', '10'], ['11', '11'], ['21', '12'],
            ['02', '00'], ['12', '01'], ['22', '02'])

        def rotate_face_inverted(squares, plan, face):
            # counter-clockwise
            plan_inverted = invert_plan(plan)
            rotate_face(squares, plan_inverted, face)

        def rotate_face(squares, plan, face):
            for change in plan:
                key_source = face + change[0]
                key_target = face + change[1]
                add_change(squares, key_source, key_target)

        # cube rotation functions
        plan_rotate_left = ('fl', 'lb', 'br', 'rf')
        plan_rotate_up = ('fu', 'ub*', 'bd*', 'df')
        plan_rotate_down = ('uf', 'bu*', 'db*', 'fd')
        plan_rotate_back = (
            ['20', '02'], ['10', '12'], ['00', '22'],
            ['21', '01'], ['11', '11'], ['01', '21'],
            ['22', '00'], ['12', '10'], ['02', '20'])

        def turn_inverted(squares, plan):
            plan_inverted = invert_plan(plan)
            turn(squares, plan_inverted)

        def turn(squares, plan):
            for change in plan:
                face_source = change[0]
                face_target = change[1]
                if len(change) == 2:
                    turn_face(squares, face_source, face_target)
                else:
                    turn_face_coordinates(squares, face_source, face_target, plan_rotate_back)

        def turn_face(squares, face_source, face_target):
            for column in range(self.elements):
                for row in range(self.elements):
                    key_source = face_source + str(column) + str(row)
                    key_target = face_target + str(column) + str(row)
                    add_change(squares, key_source, key_target)

        def turn_face_coordinates(squares, face_source, face_target, plan):
            for change in plan:
                key_source = face_source + change[0]
                key_target = face_target + change[1]
                add_change(squares, key_source, key_target)

        def invert_plan(plan):
            plan_inverted = []
            for item in plan:
                plan_inverted.append(item[::-1])
            return plan_inverted

        def add_change(squares, key_source, key_target):
            color = squares.get(key_source)
            self.squares_buffer[key_target] = color
            self.squares_to_render[key_target] = color

        def accept_buffer(squares):
            for key, color in self.squares_buffer.items():
                squares[key] = color
            self.squares_buffer.clear()
            self.cube_valid()

        # rotate()
        self.squares_to_render.clear()

        for command in commands.split():
            # slices
            if command == 'l':
                slice_coordinates(self.squares, plan_left)
                rotate_face(self.squares, plan_face, 'l')
            elif command == 'li':
                slice_coordinates_inverted(self.squares, plan_left)
                rotate_face_inverted(self.squares, plan_face, 'l')
            elif command == 'm':
                slice_coordinates(self.squares, plan_middle)
            elif command == 'mi':
                slice_coordinates_inverted(self.squares, plan_middle)
            elif command == 'r':
                slice_coordinates(self.squares, plan_right)
                rotate_face(self.squares, plan_face, 'r')
            elif command == 'ri':
                slice_coordinates_inverted(self.squares, plan_right)
                rotate_face_inverted(self.squares, plan_face, 'r')

            elif command == 'u':
                slice_row(self.squares, plan_row, 0)
                rotate_face(self.squares, plan_face, 'u')
            elif command == 'ui':
                slice_row_inverted(self.squares, plan_row, 0)
                rotate_face_inverted(self.squares, plan_face, 'u')
            elif command == 'e':
                slice_row_inverted(self.squares, plan_row, 1)
            elif command == 'ei':
                slice_row(self.squares, plan_row, 1)
            elif command == 'd':
                slice_row_inverted(self.squares, plan_row, 2)
                rotate_face(self.squares, plan_face, 'd')
            elif command == 'di':
                slice_row(self.squares, plan_row, 2)
                rotate_face_inverted(self.squares, plan_face, 'd')

            elif command == 'f':
                slice_coordinates(self.squares, plan_front)
                rotate_face(self.squares, plan_face, 'f')
            elif command == 'fi':
                slice_coordinates_inverted(self.squares, plan_front)
                rotate_face_inverted(self.squares, plan_face, 'f')
            elif command == 's':
                slice_coordinates(self.squares, plan_standing)
            elif command == 'si':
                slice_coordinates_inverted(self.squares, plan_standing)
            elif command == 'b':
                slice_coordinates(self.squares, plan_back)
                rotate_face(self.squares, plan_face, 'b')
            elif command == 'bi':
                slice_coordinates_inverted(self.squares, plan_back)
                rotate_face_inverted(self.squares, plan_face, 'b')

            # turns
            elif command == 'tl':
                turn(self.squares, plan_rotate_left)
                rotate_face(self.squares, plan_face, 'u')
                rotate_face_inverted(self.squares, plan_face, 'd')
            elif command == 'tr':
                turn_inverted(self.squares, plan_rotate_left)
                rotate_face_inverted(self.squares, plan_face, 'u')
                rotate_face(self.squares, plan_face, 'd')
            elif command == 'tu':
                turn(self.squares, plan_rotate_up)
                rotate_face_inverted(self.squares, plan_face, 'l')
                rotate_face(self.squares, plan_face, 'r')
            elif command == 'td':
                turn(self.squares, plan_rotate_down)
                rotate_face(self.squares, plan_face, 'l')
                rotate_face_inverted(self.squares, plan_face, 'r')

            else:
                print('No case defined for command:', command, '\n')
            accept_buffer(self.squares)


    ######### cube methods - find
    center_cubelets = (['l11'], ['f11'], ['r11'], ['u11'], ['b11'], ['d11'])

    edge_cubelets = (
        ['f10', 'u12'], ['f01', 'l21'], ['f21', 'r01'], ['f12', 'd10'],
        ['l10', 'u01'], ['l01', 'b21'], ['l12', 'd01'], ['u10', 'b10'],
        ['u21', 'r10'], ['b01', 'r21'], ['b12', 'd12'], ['r12', 'd21'])

    corner_cubelets = (
        ['f00', 'u02', 'l20'], ['f20', 'u22', 'r00'],
        ['f02', 'l22', 'd00'], ['f22', 'r02', 'd20'],
        ['b00', 'r20', 'u20'], ['b20', 'u00', 'l00'],
        ['b02', 'r22', 'd22'], ['b22', 'l02', 'd02'])

    def find_cubes_color(self, cublet, color):
        for key in cublet:
            if self.squares[key] == color:
                return True
        return False

    def find_cubes(self, cubelets, colors):
        for cublet in cubelets:
            for color in colors:
                if not self.find_cubes_color(cublet, color):
                    break
            else:
                return cublet
        print('Unable to find cublet {0} in {1}'.format(colors, cubelets))
        return []  # not found

    def find_center(self, colors):
        return self.find_cubes(self.center_cubelets, colors)

    def find_edge(self, colors):
        return self.find_cubes(self.edge_cubelets, colors)

    def find_corner(self, colors):
        return self.find_cubes(self.corner_cubelets, colors)

    def cublet_info(self, cubelets): # temp
        for cublet in cubelets:
            colors = []
            for key in cublet:
                colors.append(self.squares[key])
            print(cublet, colors)

    def cube_valid(self):
        def cube_valid_type(cubelets):
            for cubelet in cubelets:
                colors = []
                for key in cubelet:
                    color = self.squares[key]
                    if color in colors:
                        colors.append(color)
                        print('Cube Invalid:', cubelet, colors)
                        return False
                    else:
                        colors.append(color)
                else:
                    return True
        if not cube_valid_type(self.edge_cubelets) : return False
        if not cube_valid_type(self.corner_cubelets) : return False
        return True


    ######### cube methods - other
    def get_elements_count(self):
        return self.elements

    def get_color(self, color_key):
        return self.squares[color_key]

    def get_render_que(self):
        return self.squares_to_render

    def get_commands_display(self):
        list = ''
        for command in self.commands_base:
            if list != '' : list += ', '
            list += command[0]
        return list

    def get_commands_execute(self):
        list = []
        for command in self.commands_base:
            list.append(command[0])
        return list

    def scramble(self, commands_cnt):
        commands = self.get_commands_execute()
        commands_list = ''

        for i in range(commands_cnt):
            idx = random.randint(0, len(commands) - 1)
            if commands_list != '': commands_list += ' '
            commands_list += commands[idx]

        self.rotate(commands_list)
        self.squares_reset = self.squares.copy()
        return commands_list

    def reset(self):
        self.squares = self.squares_reset.copy()
        self.squares_to_render = self.squares_reset.copy()

    def restart(self):
        self.squares = self.squares_restart.copy()
        self.squares_to_render = self.squares_restart.copy()

class render:
    def __init__(self, cube):
        self.cube_map = {}
        self.init(cube)

    def init(self, cube):
        square_size = 50
        display_map = {}

        def init_map(cube, display_map) :
            # create map of layout of cube sides
            faces = cube.get_faces()
            elements = cube.get_elements_count()

            margin_size = square_size
            space_btw_sides = square_size

            col_cnt = 3
            label_h = 18
            cube_row = 0

            side_w = elements * square_size + space_btw_sides
            side_h = label_h + elements * square_size + space_btw_sides

            i = -1
            for face in faces:
                side_key = face[0]
                name = face[1]

                i += 1
                # determine cube face column
                cube_col = i % col_cnt

                # determine cube face row
                if i > 0 and i % col_cnt == 0 : cube_row += 1

                x_face = margin_size + (cube_col * side_w)
                y_face = margin_size + (cube_row * side_h)

                x_label = x_face + (elements * square_size / 2)
                y_label = y_face

                x_cube = x_face
                y_cube = y_label + label_h

                display_map[side_key] = [x_cube, y_cube, x_label, y_label, name]

            win_w = margin_size + (side_w * col_cnt)
            win_h = margin_size + (side_h * (cube_row + 1))

            return win_w, win_h

        def init_win(cube, display_map, win_w, win_h):
            self.win = GraphWin("Rubik's Cube Solver", win_w, win_h)

            # add label of side to each face
            for element in display_map.values():
                x = element[2]
                y = element[3]
                label_txt = element[4]

                label = Text(Point(x, y), label_txt)
                label.setSize(20)
                label.setStyle('normal')
                label.draw(self.win)

        def init_squares(cube, display_map, cube_map, square_size):
            for key, color in cube.squares.items():
                outer_border = 1  # btw outer box
                inner_border = 2  # btw inner and outer boxes

                side = key[0]
                column = int(key[1])
                row = int(key[2])

                position = display_map[side]
                x1 = position[0]
                y1 = position[1]

                x_start = x1 + (column * square_size)
                y_start = y1 + (row * square_size)

                # outer black square
                px1 = x_start + outer_border
                py1 = y_start + outer_border

                px2 = x_start + square_size - outer_border
                py2 = y_start + square_size - outer_border

                sqr_outer = Rectangle(Point(px1, py1), Point(px2, py2))
                sqr_outer.setFill('black')
                sqr_outer.draw(self.win)

                # inner colored square
                px1 = px1 + inner_border
                py1 = py1 + inner_border

                px2 = px2 - inner_border
                py2 = py2 - inner_border
                sqr_inner = Rectangle(Point(px1, py1), Point(px2, py2))
                sqr_inner.setFill(color)
                sqr_inner.draw(self.win)

                # coordinate label
                center = Point(x_start + square_size / 2, y_start + square_size / 2)
                coordinate = str(column) + ',' + str(row)
                label = Text(center, coordinate)
                label.draw(self.win)

                element = [px1, py1, sqr_outer, sqr_inner, label]
                cube_map[key] = element

        # init()
        win_w, win_h = init_map(cube, display_map)
        init_win(cube, display_map, win_w, win_h)
        init_squares(cube, display_map, self.cube_map, square_size)


    def draw(self, cube):
        squares = cube.get_render_que()
        for key, color in squares.items():
            element = self.cube_map[key]

            sqr_inner = element[3]
            sqr_inner.setFill(color)

            # label = element[4]
            # label.setText('')

    def pause(self):
        self.win.getMouse()  # Pause to view result

    def __del__(self):
        self.win.close()


class play:
    def __init__(self, cube):
        self.commands_list = cube.get_commands_display()
        self.commands_turn = (['tl', 'left'], ['tr', 'right'], ['tu', 'up'], ['td', 'down'])
        self.commands_other = (['sc', 'scramble'], ['reset', 'reset'], ['so', 'solve'], ['restart', 'restart'], ['v', 'valid'], ['q', 'quit'])

        self.help()
        self.command_line(cube)

    def help(self):
        def get_command_list(commands):
            list = ''
            for command in commands:
                if list != '': list += ', '
                list += command[0] + ' (' + command[1] + ')'
            return list

        # help
        print('\nAvailable commands...')
        print('Slices:', self.commands_list)
        print('Turns:', get_command_list(self.commands_turn))
        print('Other:', get_command_list(self.commands_other))
        print('\n')

    def command_line(self, cube):
        while True:
            inp = input('Enter commands(s) separated by spaces: ')
            if inp == 'h':
                cube.help()
            elif inp == 'sc':
                cube.scramble(10000)
                render.draw(cube)
            elif inp == 'so':
                solve(cube, render)
            elif inp == 'restart':
                cube.restart()
                render.draw(cube)
            elif inp == 'reset':
                cube.reset()
                render.draw(cube)
            elif inp == 'q':
                exit()
            elif inp == 'v':
                print('Cube Is Valid:', cube.cube_valid())
            else:
                cube.rotate(inp)
                render.draw(cube)

def solve (cube, render):
    def coordinate_of_color(cube, keys, face_color):
        for key in keys:
            color = cube.get_color(key)
            if color == face_color:
                return key
        print('face color {0} not found in keys {1}'.format(face_color, keys))
        return 'error'


    def phase1(cube, render):
        # first layer cross
        plan = {
            'f01': 'f', 'f10': 'done', 'f12': 'f', 'f21': 'fi',
            'u01': 'l', 'u10': 'bi', 'u12': 'f', 'u21': 'ri',
            'l01': 'li d l', 'l10': 'l', 'l12': 'd', 'l21': 'l d li',
            'r01': 'ui r u', 'r10': 'ri', 'r12': 'di', 'r21': 'r di r',
            'b01': 'bi di b', 'b10': 'bi', 'b12': 'di', 'b21': 'b d bi',
            'd01': 'd', 'd10': 'fi', 'd12': 'd', 'd21': 'di'}

        def phase1_exe(cube, render, face_up_color):
            face_color = cube.get_color('f11')

            target_cubelet = cube.find_edge([face_color, face_up_color])
            if target_cubelet == []: return False

            coordinate = coordinate_of_color(cube, target_cubelet, face_color)
            command = plan[coordinate]

            if command == 'done':
                return True
            else:
                cube.rotate(command)
                render.draw(cube)
                if not cube.cube_valid(): return False
                return phase1_exe(cube, render, face_up_color)

        # phase 1
        face_up = cube.get_face('f', 'u')
        face_up_color = cube.get_color(face_up + '11')

        for f in range(4):
            print('Solving for face:', cube.get_color('f11'))
            if not phase1_exe(cube, render, face_up_color): return False
            print('Turning left...')
            cube.rotate('tl')
            render.draw(cube)
        return True

    # solve
    print('Phase 1 "first layer cross" start...')
    rtn = phase1(cube, render)
    print('Phase 1 completion:', rtn)


##########################################################################
# RUN PROGRAM

cube = cube()
render = render(cube)

# cube.scramble(1000)
# render.draw(cube)
# solve(cube, render)

play = play(cube)

