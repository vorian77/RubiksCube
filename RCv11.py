# RubikCube.py by Phyllip Hall

""""
This program is a simulator and solver for the Rubik's cube puzzle.

The program will eventually be architected to allow for the solving of any sized, square Rubik’s cube. The most
popular 3x3 (6-sided/colored) cube is initially implemented.

The program uses cube move conventions defined on ruwix.com (the Twisty Puzzle Wiki), and the solving algorithm
defined on rubiksplace.com and youcandothecube.com.

I became interested in solving the Rubik's cube after seeing it being solved by a robot hand created by Open AI
(youtu.be/x4O8pojMF0w).

I’m learning Python syntax primarily through py4e.com (Python For Everyone), w3schools.com, and realpython.com.
I'm using Steve McConnell's "Code Complete: 2nd Addition" (Microsoft Press) as a software architecture style guide.
I'm using this project to learn Python syntax and modern coding conventions.

LICENSE: This is open-source software released under the terms of the
GPL (http://www.gnu.org/licenses/gpl.html).

PLATFORMS: The cube is rendered in 2D using the graphics.py library developed by
John Zelle as a companion to his book "Python Programming: An Introduction to Computer
Science" (Franklin, Beedle & Associates).

OVERVIEW: There are 4 primary classes in this program: cube(), render(), play(), and solve()
- cube() provides a 3D coordinate map of the cube and methods that simulate moves upon it:
- render() displays the FACES of the cube in an application window
- play() accepts command line input to manipulate the cube
- solve() executes a multistep algorithm that solves the cube
"""

# Version 11  03/04/20
#   * updated solve.step1() and dependent functions to support unit testing experiment
#   * updated solve - added log decorator to reduce code called by each of 7 steps
#   * for constants capitalized labels and converted lists to tuples where possible

# Version 10  11/19/19
#   * added solve Step 4 - permute top face edges
#   * added solve Step 5 - permute top face corners
#   * added solve Step 6 - solve top layer edges
#   * added solve Step 7 - solve top layer corners

# Version 9   11/17/19
#   * fixed bug in Step 3 - middle layer edges
#   * added debug code to monitor solve progress and catch infinite loops
#   * added trace file to disk to recreate solving up until point of infinate loop

# Version 8   11/13/19
#   * added solve Step 3 - middle layer edges
#   * added solve Step 2 - top corners

# Version 7   11/12/19
#   * added first solve features - Step 1 - top edges
#   * fixed tricky bug in turn up/turn down moves

# Version 6   11/11/19
#   * calculates size of window based configuration of cube
#   * fixed bug in left and right column moves
#   * added find cube method for each cube type - center, edge, corner

# Version 5   11/6/19
#   * significant refactor to classes that isolate the cube object, and allow independent and potentially
#     interchangeable processes for input, output, and solving algorithm
#   * abstracted cube class and variables to eventually use inheritance to support different cube types (eg. 3x3, 4x4)
#   * simplified logic for cube rotation, and completed the command library
#   * significantly increased the speed of cube rendering by changing the fill-color of squares rather
#     than moving them to simulate cube rotations
#   * loaded the program to GitHub to learn GitHub, for comment, and to share with other newbie deverlopers

# Version 4   11/2/19
#   * sped up visual processing by only moving effected squares rather than wiping and redrawing all squares
#     after each rotation command
#   * added a dictionary map to track cube positions

# Version 3   11/1/19
#   * added comments to better organize code
#   * added basic (18) 1/4 turn movements and ability to accept and execute a list of moves
#   * added cube scrambler

# Version 2   10/31/19
#   * made cubes more realistic with simulated black space between cubelets
#   * added mini cubes to show all 6 FACES simultaneously
#   * changed cube data structure to use alphanumerics for "side"

# Version 1   10/30/19
#   * initializes 6-sided cube, draws single side specified by user via command line


import random
import typing
import datetime
from graphics1 import *


##########################################################################
class Cube:

    #   primary methods
    #   rotate() - generates a list of changes to the cube's COLORS based on the execution of rotate commands
    #   get_render_que() - provides the list of cube face changes generated by rotate() needed to display the cube
    #   scramble() - sends a randomized set of rotation commands to the rotate method
    #   find() - returns a list of coordinates that locate requested cubes
    #   reset() - returns the cube to it's original (solved) state

    def __init__(self):
        # global cube attributes
        self.squares = {} # current state
        self.squares_to_render = {} # accumulated moves
        self.squares_restart = {} # solved
        self.squares_reset = {}  # scrambled
        self.squares_buffer = {}

        # faces
        self.FACES = {'b': ('Back', {'u': 'd', 'd': 'u', 'l': 'l', 'r': 'r'}),
                      'u': ('Up', {'u': 'b', 'd': 'f', 'l': 'l', 'r': 'r'}),
                      'd': ('Down', {'u': 'f', 'd': 'b', 'l': 'l', 'r': 'r'}),
                      'l': ('Left', {'u': 'u', 'd': 'd', 'l': 'b', 'r': 'f'}),
                      'f': ('Front', {'u': 'u', 'd': 'd', 'l': 'l', 'r': 'r'}),
                      'r': ('Right', {'u': 'u', 'd': 'd', 'l': 'f', 'r': 'b'})}

        # 3x3 cube attributes (eventually should be instance attributes in inherited class of cube)
        self.squares_per_side = 3
        self.COLORS = ('skyblue1', 'white', 'yellow', 'orange', 'lawn green', 'red')

        # slice commands for 3x3 cube
        self.SLICE_COMMANDS = (
            ('l', 'Left'), ('li', 'Left Inverted'),
            ('m', 'Middle'), ('mi', 'Middle Inverted'),
            ('r', 'Right'), ('ri', 'Right Inverted'),
            ('u', 'Up'), ('ui', 'Up Inverted'),
            ('e', 'Equatorial'), ('ei', 'Equatorial Inverted'),
            ('d', 'Down'), ('di', 'Down Inverted'),
            ('f', 'Front'), ('fi', 'Front Inverted'),
            ('s', 'Standing'), ('si', 'Standing Inverted'),
            ('b', 'Back'), ('bi', 'Back Inverted'))

        # initialize squares on cube sides
        for i, side_key in enumerate(self.FACES):
            for column in range(self.squares_per_side):
                for row in range(self.squares_per_side):
                    key = side_key + str(column) + str(row)
                    self.squares[key] = self.COLORS[i]

        self.squares_to_render = self.squares.copy()
        self.squares_restart = self.squares.copy()
        self.squares_reset = self.squares.copy()

    def get_faces(self):
        list_of_faces = []
        for key, data in self.FACES.items():
            list_of_faces.append([key, data[0]])
        return list_of_faces

    def get_face(self, ref_face, direction):
        data = self.FACES[ref_face]
        face_directions = data[1]
        return face_directions[direction]


    ######### rotation methods

    def move(self, commands):
        # executes a list of commands that manipulate the cube and it's perspective to the user

        # two types of actions - slice and turn

        # slices...
        #   9 base slice moves
        #       - l (left), m (middle), r (right), u (up), e (equatorial), d (down), f (front), s (standing), b (back)
        #       - each move turns a row or column of the puzzle in a clockwise direction from the player's perspective
        #       - if she held the puzzle facing one side and another side parallel to the ground
        #   9 inversion slice moves - li, mi, ri, ui, ei, di, fi, si, bi
        #       - target the same squares as the slices, but turn them counter clockwise

        # turns - rotate the entire cube in one of 4 directions
        #   - tu (turn up), td (turn down), tl (turn left), tr (turn right)

        # plans define how the COLORS will be changed to create the effect of slicing or turning squares on the cube
        # each plan is a set of pairs for which the squares identified by the second value are replaced
        # by the squares identified by the first value
        # some actions require to sets of moves - eg. a left turn requires the squares in the 0 column and left face
        # to be moved

        # row slice moves - new column positions same as old
        PLAN_ROW = ('fl', 'lb', 'br', 'rf')

        def slice_row_inverted(squares, plan, col):
            plan_inverted = invert_plan(plan)
            slice_row(squares, plan_inverted, col)

        def slice_row(squares, plan, row):
            for change in plan:
                for col in range(self.squares_per_side):
                    key_source = change[0] + str(col) + str(row)
                    key_target = change[1] + str(col) + str(row)
                    add_change(squares, key_source, key_target)

        # coordinate slice moves - all 12 color swaps are defined
        PLAN_LEFT = (
            ('f00', 'd00'), ('f01', 'd01'), ('f02', 'd02'),
            ('d00', 'b22'), ('d01', 'b21'), ('d02', 'b20'),
            ('b22', 'u00'), ('b21', 'u01'), ('b20', 'u02'),
            ('u00', 'f00'), ('u01', 'f01'), ('u02', 'f02'))

        PLAN_MIDDLE = (
            ('f10', 'd10'), ('f11', 'd11'), ('f12', 'd12'),
            ('d10', 'b12'), ('d11', 'b11'), ('d12', 'b10'),
            ('b12', 'u10'), ('b11', 'u11'), ('b10', 'u12'),
            ('u10', 'f10'), ('u11', 'f11'), ('u12', 'f12'))

        PLAN_RIGHT = (
            ('f20', 'u20'), ('f21', 'u21'), ('f22', 'u22'),
            ('u20', 'b02'), ('u21', 'b01'), ('u22', 'b00'),
            ('b02', 'd20'), ('b01', 'd21'), ('b00', 'd22'),
            ('d20', 'f20'), ('d21', 'f21'), ('d22', 'f22'))

        PLAN_FRONT = (
            ('u02', 'r00'), ('u12', 'r01'), ('u22', 'r02'),
            ('r00', 'd20'), ('r01', 'd10'), ('r02', 'd00'),
            ('d20', 'l22'), ('d10', 'l21'), ('d00', 'l20'),
            ('l22', 'u02'), ('l21', 'u12'), ('l20', 'u22'))

        PLAN_STANDING = (
            ('u01', 'r10'), ('u11', 'r11'), ('u21', 'r12'),
            ('r10', 'd21'), ('r11', 'd11'), ('r12', 'd01'),
            ('d21', 'l12'), ('d11', 'l11'), ('d01', 'l10'),
            ('l12', 'u01'), ('l11', 'u11'), ('l10', 'u21'))

        PLAN_BACK = (
            ('u00', 'l02'), ('u10', 'l01'), ('u20', 'l00'),
            ('l00', 'd02'), ('l01', 'd12'), ('l02', 'd22'),
            ('d02', 'r22'), ('d12', 'r21'), ('d22', 'r20'),
            ('r22', 'u20'), ('r21', 'u10'), ('r20', 'u00'))

        def slice_coordinates_inverted(squares, plan):
            plan_inverted = invert_plan(plan)
            slice_coordinates(squares, plan_inverted)

        def slice_coordinates(squares, plan):
            for change in plan:
                key_source = change[0]
                key_target = change[1]
                add_change(squares, key_source, key_target)

        # face turns
        PLAN_FACE = (
            ('00', '20'), ('10', '21'), ('20', '22'),
            ('01', '10'), ('11', '11'), ('21', '12'),
            ('02', '00'), ('12', '01'), ('22', '02'))

        def rotate_face_inverted(squares, plan, face):
            # counter-clockwise
            plan_inverted = invert_plan(plan)
            rotate_face(squares, plan_inverted, face)

        def rotate_face(squares, plan, face):
            # clockwise
            for change in plan:
                key_source = face + change[0]
                key_target = face + change[1]
                add_change(squares, key_source, key_target)

        # cube rotation functions
        PLAN_ROTATE_LEFT = ('fl', 'lb', 'br', 'rf')
        PLAN_ROTATE_UP = ('fu', 'ub*', 'bd*', 'df')
        PLAN_ROTATE_DOWN = ('uf', 'bu*', 'db*', 'fd')
        PLAN_ROTATE_BACK = (
            ('20', '02'), ('10', '12'), ('00', '22'),
            ('21', '01'), ('11', '11'), ('01', '21'),
            ('22', '00'), ('12', '10'), ('02', '20'))

        def turn_inverted(squares, plan):
            plan_inverted = invert_plan(plan)
            turn(squares, plan_inverted)

        def turn(squares, plan):
            for change in plan:
                face_source = change[0]
                face_target = change[1]
                if len(change) == 2:
                    turn_face(squares, face_source, face_target)
                else:
                    turn_face_coordinates(squares, face_source, face_target, PLAN_ROTATE_BACK)

        def turn_face(squares, face_source, face_target):
            for column in range(self.squares_per_side):
                for row in range(self.squares_per_side):
                    key_source = face_source + str(column) + str(row)
                    key_target = face_target + str(column) + str(row)
                    add_change(squares, key_source, key_target)

        def turn_face_coordinates(squares, face_source, face_target, plan):
            for change in plan:
                key_source = face_source + change[0]
                key_target = face_target + change[1]
                add_change(squares, key_source, key_target)

        def invert_plan(plan):
            plan_inverted = []
            for item in plan:
                plan_inverted.append(item[::-1])
            return plan_inverted

        def add_change(squares, key_source, key_target):
            color = squares.get(key_source)
            self.squares_buffer[key_target] = color
            self.squares_to_render[key_target] = color

        def apply_buffer(squares):
            for key, color in self.squares_buffer.items():
                squares[key] = color
            self.squares_buffer.clear()
            self.cube_valid()

        # move()
        for command in commands.split():
            # slices
            if command == 'l':
                slice_coordinates(self.squares, PLAN_LEFT)
                rotate_face(self.squares, PLAN_FACE, 'l')
            elif command == 'li':
                slice_coordinates_inverted(self.squares, PLAN_LEFT)
                rotate_face_inverted(self.squares, PLAN_FACE, 'l')
            elif command == 'm':
                slice_coordinates(self.squares, PLAN_MIDDLE)
            elif command == 'mi':
                slice_coordinates_inverted(self.squares, PLAN_MIDDLE)
            elif command == 'r':
                slice_coordinates(self.squares, PLAN_RIGHT)
                rotate_face(self.squares, PLAN_FACE, 'r')
            elif command == 'ri':
                slice_coordinates_inverted(self.squares, PLAN_RIGHT)
                rotate_face_inverted(self.squares, PLAN_FACE, 'r')

            elif command == 'u':
                slice_row(self.squares, PLAN_ROW, 0)
                rotate_face(self.squares, PLAN_FACE, 'u')
            elif command == 'ui':
                slice_row_inverted(self.squares, PLAN_ROW, 0)
                rotate_face_inverted(self.squares, PLAN_FACE, 'u')
            elif command == 'e':
                slice_row_inverted(self.squares, PLAN_ROW, 1)
            elif command == 'ei':
                slice_row(self.squares, PLAN_ROW, 1)
            elif command == 'd':
                slice_row_inverted(self.squares, PLAN_ROW, 2)
                rotate_face(self.squares, PLAN_FACE, 'd')
            elif command == 'di':
                slice_row(self.squares, PLAN_ROW, 2)
                rotate_face_inverted(self.squares, PLAN_FACE, 'd')

            elif command == 'f':
                slice_coordinates(self.squares, PLAN_FRONT)
                rotate_face(self.squares, PLAN_FACE, 'f')
            elif command == 'fi':
                slice_coordinates_inverted(self.squares, PLAN_FRONT)
                rotate_face_inverted(self.squares, PLAN_FACE, 'f')
            elif command == 's':
                slice_coordinates(self.squares, PLAN_STANDING)
            elif command == 'si':
                slice_coordinates_inverted(self.squares, PLAN_STANDING)
            elif command == 'b':
                slice_coordinates(self.squares, PLAN_BACK)
                rotate_face(self.squares, PLAN_FACE, 'b')
            elif command == 'bi':
                slice_coordinates_inverted(self.squares, PLAN_BACK)
                rotate_face_inverted(self.squares, PLAN_FACE, 'b')

            # turns
            elif command == 'tl':
                turn(self.squares, PLAN_ROTATE_LEFT)
                rotate_face(self.squares, PLAN_FACE, 'u')
                rotate_face_inverted(self.squares, PLAN_FACE, 'd')
            elif command == 'tr':
                turn_inverted(self.squares, PLAN_ROTATE_LEFT)
                rotate_face_inverted(self.squares, PLAN_FACE, 'u')
                rotate_face(self.squares, PLAN_FACE, 'd')
            elif command == 'tu':
                turn(self.squares, PLAN_ROTATE_UP)
                rotate_face_inverted(self.squares, PLAN_FACE, 'l')
                rotate_face(self.squares, PLAN_FACE, 'r')
            elif command == 'td':
                turn(self.squares, PLAN_ROTATE_DOWN)
                rotate_face(self.squares, PLAN_FACE, 'l')
                rotate_face_inverted(self.squares, PLAN_FACE, 'r')

            else:
                print('No case defined for command:', command, '\n')

            apply_buffer(self.squares)

    ######### cube methods - find
    CENTER_CUBELETS = (['l11'], ['f11'], ['r11'], ['u11'], ['b11'], ['d11'])

    EDGE_CUBELETS = (
        ('f10', 'u12'), ('f01', 'l21'), ('f21', 'r01'), ('f12', 'd10'),
        ('l10', 'u01'), ('l01', 'b21'), ('l12', 'd01'), ('u10', 'b10'),
        ('u21', 'r10'), ('b01', 'r21'), ('b12', 'd12'), ('r12', 'd21'))

    CORNER_CUBELETS = (
        ('f00', 'u02', 'l20'), ('f20', 'u22', 'r00'),
        ('f02', 'l22', 'd00'), ('f22', 'r02', 'd20'),
        ('b00', 'r20', 'u20'), ('b20', 'u00', 'l00'),
        ('b02', 'r22', 'd22'), ('b22', 'l02', 'd02'))

    def color_in_cubelet(self, cublet, color):
        for key in cublet:
            if self.squares[key] == color:
                return True
        return False

    def find_cubelet(self, *colors):
        # returns cubelet consisting of *COLORS

        def find_cubelet_type(cubelets, *colors):

            def get_cubelet(cublet, *colors):

                def get_cubelet_color_key(cubelet, color):
                    for key in cubelet:
                        if self.squares[key] == color:
                            return key
                    else:
                        return False

                # get_cubelet
                rtn_cubelet = []
                for color in colors:
                    key = get_cubelet_color_key(cubelet, color)
                    if key:
                        rtn_cubelet.append(key)
                    else:
                        return None
                else:
                    return rtn_cubelet

            # find_cubelet_type
            for cubelet in cubelets:
                target_cubelet = get_cubelet(cubelet, *colors)
                if target_cubelet:
                    return target_cubelet
            else:
                return None

        # find_cubelet
        color_cnt = len(colors)
        if 1 == color_cnt:
            return find_cubelet_type(self.CENTER_CUBELETS, *colors)
        elif 2 == color_cnt:
            return find_cubelet_type(self.EDGE_CUBELETS, *colors)
        elif 3 == color_cnt:
            return find_cubelet_type(self.CORNER_CUBELETS, *colors)
        else:
            print('cube.find_cubelet - no case defined for COLORS:', *colors)
            return None

    def cube_valid(self):
        def cube_valid_squares():
            colors = {}
            for color in self.squares.values():
                # build histogram
                colors[color] = colors.get(color, 0) + 1
            for color, color_cnt in colors.items():
                if color_cnt != 9:
                    print(f'Cube Invalid - color {color} - color_count{color_cnt}')
                    return False
            #print(f'Cube COLORS are valid')
            return True

        def cube_valid_type(cubelets):
            valid_cubelets = {}
            for cubelet in cubelets:
                colors = []
                for key in cubelet:
                    color = self.squares[key]
                    if color in colors:
                        colors.append(color)
                        print('Cube Invalid:', cubelet, colors)
                        return False
                    else:
                        colors.append(color)

                # cubelet
                #cubelet.sort()
                key = ''.join(cubelet)
                colors.sort()
                if key in valid_cubelets:
                    print(f'Cube Invalid - cubelet {cubelet} - color{colors}')
                    return False
                else:
                    valid_cubelets[key] = colors
                #print(f'Cublet is valid: {cubelet} - COLORS {COLORS}')
            return True

        if not cube_valid_squares(): return False

        if not cube_valid_type(self.CENTER_CUBELETS): return False
        if not cube_valid_type(self.EDGE_CUBELETS) : return False
        if not cube_valid_type(self.CORNER_CUBELETS) : return False
        return True


    ######### cube methods - other
    def get_squares_per_side(self):
        return self.squares_per_side

    def get_color(self, color_key):
        return self.squares[color_key]

    def get_render_que(self):
        squares_temp = self.squares_to_render.copy()
        self.squares_to_render.clear()
        return squares_temp

    def get_commands_display(self):
        list = ''
        for command in self.SLICE_COMMANDS:
            if list != '' : list += ', '
            list += command[0]
        return list

    def get_commands_execute(self):
        list = []
        for command in self.SLICE_COMMANDS:
            list.append(command[0])
        return list

    def scramble(self, commands_cnt):
        commands = self.get_commands_execute()
        commands_list = ''

        for i in range(commands_cnt):
            idx = random.randint(0, len(commands) - 1)
            if commands_list != '': commands_list += ' '
            commands_list += commands[idx]

        self.move(commands_list)
        self.squares_reset = self.squares.copy()
        return commands_list

    def reset(self):
        self.squares = self.squares_reset.copy()
        self.squares_to_render = self.squares_reset.copy()

    def restart(self):
        self.squares = self.squares_restart.copy()
        self.squares_to_render = self.squares_restart.copy()

##########################################################################
class Render:

    def __init__(self, cube, drawing_on=True):
        self.win = GraphWin
        self.win_w = 0
        self.win_h = 0
        self.render_on = drawing_on
        self.win_inititated = False
        self.display_map = {}
        self.cube_map = {}
        self.square_size = 50

        self.win_w, self.win_h = self.init_map(cube, self.display_map, self.square_size)

    def display_on(self):
        self.render_on = True

    def display_off(self):
        self.render_on = False

    def init_map(self, cube, display_map, square_size):
        # create map of layout of cube sides
        faces = cube.get_faces()
        elements = cube.get_squares_per_side()

        margin_size = square_size
        space_btw_sides = square_size

        col_cnt = 3
        label_h = 18
        cube_row = 0

        side_w = elements * square_size + space_btw_sides
        side_h = label_h + elements * square_size + space_btw_sides

        i = -1
        for face in faces:
            side_key = face[0]
            name = face[1]

            i += 1
            # determine cube face column
            cube_col = i % col_cnt

            # determine cube face row
            if i > 0 and i % col_cnt == 0: cube_row += 1

            x_face = margin_size + (cube_col * side_w)
            y_face = margin_size + (cube_row * side_h)

            x_label = x_face + (elements * square_size / 2)
            y_label = y_face

            x_cube = x_face
            y_cube = y_label + label_h

            display_map[side_key] = [x_cube, y_cube, x_label, y_label, name]

        win_w = margin_size + (side_w * col_cnt)
        win_h = margin_size + (side_h * (cube_row + 1))

        return win_w, win_h

    def init_win(self, display_map, w, h):
        self.win = GraphWin("Rubik's Cube Solver", w, h)

        # add label of side to each face
        for element in display_map.values():
            x = element[2]
            y = element[3]
            label_txt = element[4]

            label = Text(Point(x, y), label_txt)
            label.setSize(20)
            label.setStyle('normal')
            label.draw(self.win)

    def init_squares(self, cube, display_map, cube_map, square_size):
        for key, color in cube.squares.items():
            outer_border = 1  # white space between outer boxes
            inner_border = 2  # space btw inner and outer boxes

            side = key[0]
            column = int(key[1])
            row = int(key[2])

            position = display_map[side]
            x1 = position[0]
            y1 = position[1]

            x_start = x1 + (column * square_size)
            y_start = y1 + (row * square_size)

            # outer black square
            px1 = x_start + outer_border
            py1 = y_start + outer_border

            px2 = x_start + square_size - outer_border
            py2 = y_start + square_size - outer_border

            sqr_outer = Rectangle(Point(px1, py1), Point(px2, py2))
            sqr_outer.setFill('black')
            sqr_outer.draw(self.win)

            # inner colored square
            px1 = px1 + inner_border
            py1 = py1 + inner_border

            px2 = px2 - inner_border
            py2 = py2 - inner_border
            sqr_inner = Rectangle(Point(px1, py1), Point(px2, py2))
            sqr_inner.setFill(color)
            sqr_inner.draw(self.win)

            # coordinate label
            center = Point(x_start + square_size / 2, y_start + square_size / 2)
            coordinate = str(column) + ',' + str(row)
            label = Text(center, coordinate)
            label.draw(self.win)

            element = [px1, py1, sqr_outer, sqr_inner, label]
            #element = [px1, py1, sqr_outer, sqr_inner]
            cube_map[key] = element

    def init_draw(self, cube):
        # init_draw
        self.init_win(self.display_map, self.win_w, self.win_h)
        self.init_squares(cube, self.display_map, self.cube_map, self.square_size)

    def draw(self, cube):
        if not self.render_on:
            return

        if not self.win_inititated:
            self.init_draw(cube)
            self.win_inititated = True
        else:
            squares = cube.get_render_que()
            for key, color in squares.items():
                element = self.cube_map[key]

                sqr_inner = element[3]
                sqr_inner.setFill(color)

    def __del__(self):
        if self.win_inititated:
            self.win.close()

##########################################################################
def play(cube, render):
    commands_list = cube.get_commands_display()
    COMMANDS_TURN = (('tl', 'left'), ('tr', 'right'), ('tu', 'up'), ('td', 'down'))
    COMMANDS_OTHER = (('sc', 'scramble'), ('reset', 'reset'), ('so', 'solve'), ('restart', 'restart'), ('v', 'valid'), ('t', 'test'), ('q', 'quit'), ('h', 'help'))

    def help():
        def get_command_list(commands):
            list = ''
            for command in commands:
                if list != '': list += ', '
                list += command[0] + ' (' + command[1] + ')'
            return list

        # help
        print('\nAvailable commands...')
        print('Slices:', commands_list)
        print('Turns:', get_command_list(COMMANDS_TURN))
        print('Other:', get_command_list(COMMANDS_OTHER))
        print('\n')

    def command_line(cube):
        while True:
            inp = input('Enter commands(s) separated by spaces: ').lower()
            if inp == 'h':
                help()
            elif inp == 'sc':
                cube.scramble(1000)
                render.draw(cube)
            elif inp == 'so':
                solve.solve_cube()
            elif inp == 'restart':
                cube.restart()
                render.draw(cube)
            elif inp == 'reset':
                cube.reset()
                render.draw(cube)
            elif inp == 'q':
                exit()
            elif inp == 'v':
                print('Cube Is Valid:', cube.cube_valid())
            elif inp == 't':
                test(50, False)
            else:
                cube.move(inp)
                render.draw(cube)

    # play
    help()
    command_line(cube)

##########################################################################
class Solve(object):
    def __init__(self, cube, render):
        self.cube = cube
        self.render = render
        self.fout = typing.TextIO
        self.last_commands = ['', 0] # [command name, # of repeats] - used to determine if commands are looping
        self.log_step = ''
        self.log_squares_to_solve = tuple()

    def log_file_init(self):
        self.fout = open('rubikscube_trace.txt', 'w')
        self.fout.write(str(datetime.datetime.now()) + '\n')

    def log_file_close(self):
        self.fout.close()

    def command_in_loop(self, commands):
        max_repeat_cnt = 10

        if commands != self.last_commands[0]:
            self.last_commands[0] = commands
            self.last_commands[1] = 1
            return False
        else:
            if self.last_commands[1] < max_repeat_cnt:
                repeats = self.last_commands[1] + 1
                self.last_commands[1] = repeats
                return False
            else:
                self.msg_user('Commands are looping')
                return True

    def msg_user(self, message):
        if isinstance(self.fout.name, str):
            self.fout.write(message + '\n')
        print(message)

    def move_cube(self, commands, message):
        self.msg_user(message)

        if self.command_in_loop(commands):
            return False
        else:
            self.cube.move(commands)
            self.render.draw(self.cube)
            return True

    def get_unsolved_squares(self, squares_to_solve):
        unsolved_squares = []
        for square in squares_to_solve:
            square_color = self.cube.get_color(square)
            face_color = self.cube.get_color(square[0] + '11')
            if square_color != face_color:
                    unsolved_squares.append(square)
        return unsolved_squares

    def step_start(self, step, squares_to_solve = []):
        self.msg_user(f'\nStep: "{step}")')
        if len(squares_to_solve) > 0:
            self.msg_user(f'Squares to solve: {squares_to_solve}')

    def step_end(self, step, squares_to_solve = []):
        unsolved_squares = self.get_unsolved_squares(squares_to_solve)
        if unsolved_squares == []:
            self.msg_user(f'Step "{step}" successfully solved')
            return True
        else:
            self.msg_user(f'Unsolved squares of Step: "{step}" {unsolved_squares}')
            return False

    def process_step(self, step_func, step_nbr, step_desc, squares_to_solve):
        step_name = str(step_nbr) + ' - ' + step_desc
        self.step_start(step_name, squares_to_solve)
        if not step_func(step_name, squares_to_solve):
            return False
        return self.step_end(step_name, squares_to_solve)

    def step1(self, step_name, squares_to_solve):
        def position_edge(cube, color_f10, color_u12):
            # positions cubelet consisting of COLORS
            # color_f10 (to position 'f10') and
            # color_u12 (to position 'u12')

            PLAN = {
                'f01': 'f', 'f10': 'done', 'f12': 'f', 'f21': 'fi',
                'u01': 'l', 'u10': 'bi', 'u12': 'f', 'u21': 'ri',
                'l01': 'li d l', 'l10': 'l', 'l12': 'd', 'l21': 'l d li',
                'r01': 'ui r u', 'r10': 'ri', 'r12': 'di', 'r21': 'r di ri',
                'b01': 'bi di b', 'b10': 'bi', 'b12': 'di', 'b21': 'b d bi',
                'd01': 'd', 'd10': 'fi', 'd12': 'd', 'd21': 'di'}

            def get_cubelet_key(cubelet, target_color):
                for key in cubelet:
                    if target_color == self.cube.get_color(key):
                        return key
                else:
                    self.msg_user(f'Color: {target_color} not found in keys: {cubelet}')
                    return None

            while True:
                target_cubelet = cube.find_cubelet(color_f10, color_u12)
                if target_cubelet is None: return False

                coordinate = get_cubelet_key(target_cubelet, color_f10)
                if coordinate is None:
                    return False
                command = PLAN[coordinate]

                if command == 'done':
                    return True
                else:
                    if not self.move_cube(command, 'Executing command:' + command):
                        return False

        # step1
        for face in range(4):
            self.msg_user('Solving face:' + self.cube.get_color('f11'))

            # set top layer edge for face
            front_face_color = self.cube.get_color('f11')
            top_face_color = self.cube.get_color('u11')
            if not position_edge(self.cube, front_face_color, top_face_color):
                return False

            self.move_cube('tl', 'Turning left...')
        return True

    def step2(self, step_name, squares_to_solve):
        def get_corner_cubelet():
            up_face_color = self.cube.get_color('u11')
            front_face_color = self.cube.get_color('f11')
            right_face_color = self.cube.get_color('r11')
            return self.cube.find_cubelet(up_face_color, front_face_color, right_face_color)

        def cubelet_solved(cubelet):
            for square in cubelet:
                square_color = self.cube.get_color(square)
                face_color = self.cube.get_color(square[0] + '11')
                if square_color != face_color:
                    return False
            else:
                return True

        def pre_position_cube(cubelet):
            key = ''
            command = ''
            PLAN = {'b00r20u20': 'r di di ri d', 'b02d22r22': 'di', 'b20l00u00': 'li d d l', 'b22d02l02': 'd d',
                    'd00f02l22': 'd', 'd20f22r02': 'done', 'f00l20u02': 'l d li', 'f20r00u22': 'ri di r d'}

            # check - already solved
            if cubelet_solved(['f20', 'u22', 'r00']):
                return

            cubelet.sort()
            key = ''.join(cubelet)
            command = PLAN[key]
            if command == 'done': return
            self.move_cube(command, 'Positioning edge: ' + str(cubelet))

        def final_position_cube():
            command = ''

            # check - already solved
            if cubelet_solved(['f20', 'u22', 'r00']): return

            up_face_color = self.cube.get_color('u11')
            if up_face_color == self.cube.get_color('f22'):
                command = 'f d fi'
            elif up_face_color == self.cube.get_color('r02'):
                command = 'ri di r'
            else:
                command = 'ri d d r d ri di r'
            self.move_cube(command, 'Solving edge: ' + str(cubelet))

        # step2
        for face in range(4):
            self.msg_user('Solving face:' + self.cube.get_color('f11'))
            cubelet = get_corner_cubelet()
            pre_position_cube(cubelet)
            final_position_cube()
            self.move_cube('tl', 'Turning left...')
        return True

    def step3(self, step_name, squares_to_solve):
        INSERT_MIDDLE_EDGE_01 = 'ui li u l u f ui fi'
        INSERT_MIDDLE_EDGE_21 = 'u r ui ri ui fi u f'

        def rotate_to_front_color(new_front_color):
            if self.cube.get_color('f11') != new_front_color:
                if not self.move_cube('tl', 'Rotating cube to front color:' + new_front_color):
                    return False
                else:
                    return rotate_to_front_color(new_front_color)

        def position_top_layer_edge(key):
            color = self.cube.get_color(key)
            if color == self.cube.get_color(key[0] + '11'):
                if not rotate_to_front_color(color):
                    return False
            else:
                if not self.move_cube('e d', 'Rotating bottom two layers of cube to form body upside down "T"...'):
                    return False
                position_top_layer_edge(key)
                return True

        def next_edge():
            misoriented_edge = []
            unsolved_edges = get_unsolved_edges()
            if len(unsolved_edges) == 0:
                return True

            for edge in unsolved_edges:
                found, key = edge_in_top_row(edge)
                if found:
                    return swap_down(key)
                else:
                    misoriented_edge = edge
            else:
                # only misoriented edges unsolved
                return swap_up(misoriented_edge)

        def swap(commands, key, type):
            self.move_cube(commands, f'Swapping "{type}" edge piece {key}')
            return next_edge()

        def swap_down(key):
            commands = ''
            position_top_layer_edge(key)

            # determine edge placement algorithm
            color_of_top_edge = self.cube.get_color('u12')
            if color_of_top_edge == self.cube.get_color('l11'):
                commands = INSERT_MIDDLE_EDGE_01
            elif color_of_top_edge == self.cube.get_color('r11'):
                commands = INSERT_MIDDLE_EDGE_21
            return swap(commands, key, 'down')

        def swap_up(edge):
            # using 1st square but either would work
            commands = ''
            key = edge[0]
            face = key[0]
            coordinate = key[1:]

            # turn so that key is on face
            color = self.cube.get_color(face + '11')
            rotate_to_front_color(color)

            # get swap commands
            if coordinate == '01':
                commands = INSERT_MIDDLE_EDGE_01
            else:
                commands = INSERT_MIDDLE_EDGE_21
            return swap(commands, key, 'up')

        def edge_is_solved(edge):
            # true if edge square COLORS are same as their face COLORS
            for key in edge:
                if self.cube.get_color(key) != self.cube.get_color(key[0] + '11'):
                    return False
            else:
                return True

        def get_unsolved_edges():
            EDGES_TO_SOLVE = (('f01', 'l21'), ('f21', 'r01'), ('r21', 'b01'), ('b21', 'l01'))
            unsolved_edges = []
            for edge in EDGES_TO_SOLVE:
                if not edge_is_solved(edge):
                    unsolved_edges.append(edge)
            return unsolved_edges

        def edge_in_top_row(target_edge):
            # target_edge represents coordinates of middle layer edge to be solved
            # found_edge is edge to be positioned in target_edge coordinates
            # retrns true if either color of found_edge has coordinate '10'
            colors = []
            found_edge = []
            color0 = self.cube.get_color(target_edge[0][0] + '11')
            color1 = self.cube.get_color(target_edge[1][0] + '11')
            found_edge = self.cube.find_cubelet(color0, color1)

            for key in found_edge:
                if key in ['f10', 'l10', 'b10', 'r10']:
                    return True, key
            else:
                return False, None

        # step3
        # flip cube upside down
        if not self.move_cube('tu tu', 'Flipping cube upside down...'):
            return False
        return next_edge()

    def step4(self, step_name, squares_to_solve):
        def get_status_item(coordinates_to_check):
            unsoloved_coordinates = []
            top_face_color = self.cube.get_color('u11')

            # create list of coordinates that should not be solved
            for key in squares_to_solve:
                if key[1:] not in coordinates_to_check:
                    unsoloved_coordinates.append(key[1:])

            # check coordinates that should be solved
            for coordinate in coordinates_to_check:
                if top_face_color != self.cube.get_color('u' + coordinate):
                    return False

            # check coordinates of that should not be solved
            for coordinate in unsoloved_coordinates:
                if top_face_color == self.cube.get_color('u' + coordinate):
                    return False

            return True

        def get_status():
            state = 0
            coordinates = []
            commands = ''
            PLAN = (
                (1, (), None),
                (2, ('10', '12'), 'u'),
                (2, ('01', '21'), None),
                (3, ('12', '01'), 'u'),
                (3, ('21', '12'), 'u u'),
                (3, ('10', '21'), 'ui'),
                (3, ('01', '10'), None),
                (4, ('01', '10', '12', '21'), None),
            )
            for i in PLAN:
                state = i[0]
                coordinates = i[1]
                commands = i[2]
                if get_status_item(coordinates):
                    return state, commands
        # step4
        state = 0
        reposition_commands = ''

        while True:
            state, reposition_commands = get_status()
            if state == 4:
                break
            elif reposition_commands != None:
                self.move_cube(reposition_commands, 'Repositioning cube for state: ' + str(state))

            # advance state
            self.move_cube('ri ui fi u f r', 'Advance from state: ' + str(state))
        return True

    def step5(self, step_name, squares_to_solve):
        solved_corners_cnt = 0

        def solved_squares_cnt(squares):
            top_color = ''
            squares_cnt = 0

            top_color = self.cube.get_color('u11')
            for square in squares:
                if self.cube.get_color(square) == top_color:
                    squares_cnt += 1
            return squares_cnt

        def position_cube(squares):
            top_color = ''

            top_color = self.cube.get_color('u11')
            for i in range(0,3):
                if len(squares) == solved_squares_cnt(squares):
                    return
                else:
                    self.move_cube('u', f'Turning to have {top_color} as squares {squares}')

        #step5
        for i in range(3):
            solved_corners_cnt = solved_squares_cnt(('u00', 'u20', 'u02', 'u22'))

            if solved_corners_cnt == 0:
                position_cube(('l20',))
            elif solved_corners_cnt == 1:
                position_cube(('u10', 'u01', 'u11', 'u21', 'u02', 'u12'))
            elif solved_corners_cnt == 2:
                position_cube(('f00',))
            elif solved_corners_cnt == 4:
                break

            self.move_cube('r u ri u r u u ri', 'Advance from state: ' + str(solved_corners_cnt))
        return True

    def step6(self, step_name, squares_to_solve):
        solved_corners_cnt = 0
        solved_corners = []
        ROTATE_COMMANDS = 'ri f ri b b r fi ri b b r r ui'

        def get_solved_corners():
            corners = []
            CUBELETS_TO_SOLVE = (
                ['u00', 'l00', 'b20'], ['u20', 'r20', 'b00'],
                ['u02', 'l20', 'f00'], ['u22', 'r00', 'f20']
            )
            for cubelet in CUBELETS_TO_SOLVE:
                for key in cubelet:
                    if self.cube.get_color(key) != self.cube.get_color(key[0] + '11'):
                        break
                else:
                    corners.append(cubelet)
            else:
                return corners, len(corners)

        def solved_corners_are_adjacent(solved_corners):
            PLAN = ((('u00', 'u20'), ''), (('u20', 'u22'), 'tr'), (('u22', 'u02'), 'tl tl'), (('u02', 'u00'), 'tl'))
            solved_squares_combined = sum(solved_corners, [])

            for item in PLAN:
                coordinates = item[0]
                command = item[1]

                for key in coordinates:
                    if key not in solved_squares_combined:
                        break
                else:
                    # position adjacent solved corners to back
                    if command != '':
                        self.move_cube(command, 'Rotating cube to place 2 solved corners in back state')
                    return True
            else:
                return False

        def position_corners():
            while True:
                solved_corners, solved_corners_cnt = get_solved_corners()

                if solved_corners_cnt == 4:
                    return solved_corners, 'done'
                elif solved_corners_cnt == 2:
                    if solved_corners_are_adjacent(solved_corners):
                        return solved_corners, 'adjacent'
                    else:
                        return solved_corners, 'diagonal'
                self.move_cube('u', 'Rotating top face to realize 2 solved corners state')

        # step6
        solved_corners, state = position_corners()

        if state == 'done':
            return True
        elif state == 'adjacent':
            self.move_cube(ROTATE_COMMANDS, 'Rotating adjacent corners')
        elif state == 'diagonal':
            self.move_cube(ROTATE_COMMANDS, 'Rotating diagonal corners')
            position_corners()
            self.move_cube(ROTATE_COMMANDS, 'Rotating adjacent corners')

        # step is complete
        solved_corners, solved_corners_cnt = get_solved_corners()
        return solved_corners_cnt == 4

    def step7(self, step_name, squares_to_solve):
        solved_edges_cnt = 0
        solved_edges = []
        COMMANDS_ROTATE_CLOCKWISE ='f f u l ri f f li r u f f'
        COMMANDS_ROTATE_COUNTER_CLOCKWISE = 'f f ui l ri f f li r ui f f'

        def get_solved_edges():
            edges = []
            CUBELETS_TO_SOLVE = (('u01', 'l10'), ('u10', 'b10'), ('u21', 'r10'), ('u12', 'f10'))

            for cubelet in CUBELETS_TO_SOLVE:
                for key in cubelet:
                    if self.cube.get_color(key) != self.cube.get_color(key[0] + '11'):
                        break
                else:
                    edges.append(cubelet)
            else:
                return edges, len(edges)

        def move_edge_to_back(edges):
            for edge in edges:
                if 'u01' in edge:
                    self.move_cube('tl', 'Rotating edge "u01" to back.')
                elif 'u21' in edge:
                    self.move_cube('tr', 'Rotating edge "u21" to back.')
                elif 'u12' in edge:
                    self.move_cube('tl tl', 'Rotating edge "u12" to back.')

        def process_edges(edge, commands_clockwise, commands_counter_clockwise):
            commands = ''
            move_edge_to_back( edge)
            if self.cube.get_color('r10') == self.cube.get_color('f11'):
                commands = commands_clockwise
            else:
                commands = commands_counter_clockwise
            self.move_cube(commands, 'Solving 3 top layer edges.')

        # step7
        solved_edges, solved_edges_cnt = get_solved_edges()

        if solved_edges_cnt == 1:
            process_edges(solved_edges, COMMANDS_ROTATE_CLOCKWISE, COMMANDS_ROTATE_COUNTER_CLOCKWISE)
        else:
            self.move_cube(COMMANDS_ROTATE_CLOCKWISE, 'Creating single solved edge.')
            solved_edges, solved_edges_cnt = get_solved_edges()
            process_edges(solved_edges, COMMANDS_ROTATE_CLOCKWISE, COMMANDS_ROTATE_COUNTER_CLOCKWISE)

        solved_edges, solved_edges_cnt = get_solved_edges()
        return solved_edges_cnt == 4

    def solve_cube(self):
        def solve_steps():
            if not self.process_step(self.step1, 1, 'solve top layer edges', ('f10', 'r10', 'b10', 'l10', 'u10', 'u01', 'u21', 'u12')): return False
            if not self.process_step(self.step2, 2, 'solve top layer corners', ('f00', 'f20', 'r00', 'r20', 'b00', 'b20', 'l00', 'l20', 'u00', 'u20', 'u02', 'u22')): return False
            if not self.process_step(self.step3, 3, 'solve middle layer edges', ('f01', 'f21', 'l01', 'l21', 'b01', 'b21', 'r01', 'r21')): return False
            if not self.process_step(self.step4, 4, 'permute top face edges', ('u01', 'u10', 'u12', 'u21')): return False
            if not self.process_step(self.step5, 5, 'permute top face corners', ()): return False
            if not self.process_step(self.step6, 6, 'solve top layer corners', ('u00', 'l00', 'b20', 'u20', 'r20', 'b00', 'u02', 'f00', 'l20', 'u22', 'f20', 'r00')): return False
            if not self.process_step(self.step7, 7, 'solve top layer edges', ('u10', 'b10', 'u01', 'l10', 'u21', 'r10', 'u12', 'f10')): return False
            return True

        # solve_cube
        self.log_file_init()
        success = solve_steps()
        self.msg_user('Cube solved successfully: ' + str(success))
        self.log_file_close()
        return success


def test(solve_cnt, display_status):
    if display_status:
        render.display_on()
    else:
        render.display_off()

    for i in range(1, solve_cnt+1):
        print('\nSolving iteration #', i)
        cube.scramble(100)
        if display_status:
            render.draw(cube)
        if not solve.solve_cube():
            cube.reset()
            print(f'Solve failed on attempt: {i}')
            break
    else:
        print(f'Solve ran successfully {i} times')

    render.display_on()
    render.draw(cube)

##########################################################################
# RUN PROGRAM

cube = Cube()
render = Render(cube, True)
solve = Solve(cube, render)

def main():
    render.draw(cube)
    play(cube, render)

if __name__ == '__main__':
    main()
